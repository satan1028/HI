#ifndef CORRELATIONS_TEST_WRITEDATA_H
#define CORRELATIONS_TEST_WRITEDATA_H
/**
 * @file   correlations/test/WriteData.hh
 * @author Christian Holm Christensen <cholm@nbi.dk>
 * @date   Thu Oct 24 23:45:40 2013
 *
 * @brief  Example event generator
 */
/*
 * Multi-particle correlations 
 * Copyright (C) 2013 K.Gulbrandsen, A.Bilandzic, C.H. Christensen.
 * 
 * This program is free software: you can redistribute it and/or
 * modify it under the terms of the GNU General Public License as
 * published by the Free Software Foundation, either version 3 of the
 * License, or (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 * General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see http://www.gnu.org/licenses.
 */
#include <correlations/Types.hh>
#include <correlations/test/Random.hh>
#include <correlations/test/Distribution.hh>
#include <correlations/test/Weights.hh>
#include <correlations/test/Stopwatch.hh>
#include <fstream>

namespace correlations {
  /**
   * Namespace for testing code
   */
  namespace test {
    /**
     * Example generator. 
     *
     * This generator uses correlations::test::Distribution and
     * correlations::test::Weights. 
     * 
     * @code 
     * std::ofstream out("data.dat"); 
     * correlations::test::WriteData w(20,30);
     * w.Run(out, nEvents);
     * @endcode
     *
     * @headerfile "" <correlations/test/WriteData.hh>
     */
    struct WriteData
    {
      WriteData(Size minN, Size maxN)
	: _d(),
	  _w(),
	  _minN(minN),
	  _maxN(maxN)
      {}
      /**
       * Create one event
       *
       * @param o  Output stream
       * @param ev Event number
       */
      void event(std::ostream& o, Size ev)
      {
	_d.setup(Random::asReal(0, 2 * M_PI));

	Size mult = Random::asSize(_minN, _maxN);

	// Write out a header:
	//   -1  multiplicity event_no phiR
	o << -1 << "\t" << mult << "\t" << ev << "\t" << _d._v[0] << std::endl;

	// Generate observations
	for (Size ipart = 0; ipart < mult; ipart++) {
	  Real phi    = _d.random();
	  Real weight = _w.eval(phi);

	  // Write particle line:
	  //   no phi weight
	  o << ipart << "\t" << phi << "\t" << weight << std::endl;
	}
	// Write trailer:
	//   -2 multiplicity event_no
	o << -2 << "\t" << mult << "\t" << ev << std::endl;
      }
      /**
       * Run a job
       *
       * @code
       * WriteData w(800, 1000);
       * w.Run(std::cout, 100, false);
       * @endcode
       *
       * @param o          Output stream
       * @param nEvents    Number of events to make
       * @param verb       Wheter to print progress to standard output
       * @param prec       Precision to use
       */
      void run(std::ostream& o, Size nEvents, bool verb=true, Size prec=16)
      {
	Size oprec = o.precision();
	o.precision(prec);

	o << "# Data file generated by WriteData\n"
	  << "# nEvents=" << nEvents << '\n'
	  << "# mult in [" << _minN << "," << _maxN << ")\n"
	  << "# flow parameters:\n";
	for (Size par = 1; par < 7; par++)
	  o << "#  v" << par << ": " << _d._v[par] << "\n";
	o << std::flush;

	for (Size ev = 0; ev < nEvents; ev++) {
	  bool print = (verb && ((ev+1) % (nEvents/10)) == 0);
	  if (print) std::cout << "Event # " << (ev+1) << " ... " << std::flush;
	  event(o, ev);
	  if (print) std::cout << "done" << std::endl;
	}
	o << "# EOF" << std::endl;
	o.precision(oprec);
      }
      /**
       * Run a job
       *
       * @code
       * WriteData w(800, 1000);
       * w.Run("data.dat", 100, true);
       * @endcode
       *
       * @param outfile  Output file to write to
       * @param nEvents  Number of events to make
       * @param verb     Wheter to print progress to standard output
       * @param prec     Precision to use
       */
      void run(const std::string& outfile, Size nEvents, bool verb=true,
	       Size prec=32)
      {
	std::ofstream out(outfile.c_str());
	if (!out) {
	  std::cerr << "Failed to make the output file: " << outfile 
		    << std::endl;
	  return;
	}
	run(out, nEvents, verb, prec);
	out.close();
      }
      /** Phi distribution */
      Distribution            _d;
      /** Weigths */
      Weights                 _w;
      /** Least multiplicity */
      Size _minN;
      /** Larges multiplicity */
      Size _maxN;
    };
  }
}
#endif
// Local Variables:
//  mode: C++
// End:
