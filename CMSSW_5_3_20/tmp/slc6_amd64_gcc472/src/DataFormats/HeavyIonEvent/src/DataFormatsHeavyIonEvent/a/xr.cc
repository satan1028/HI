// Generated at Tue Apr 14 11:27:34 2015. Do not modify it

/*
GCC-XML version 0.9.0
Configuration settings:
  GCCXML_CONFIG="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms3/share/gccxml-0.9/gccxml_config"
  GCCXML_COMPILER="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/c++"
  GCCXML_CXXFLAGS=""
  GCCXML_EXECUTABLE="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms3/bin/gccxml_cc1plus"
  GCCXML_CPP="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms3/bin/gccxml_cc1plus"
  GCCXML_FLAGS="-D__DBL_MIN_EXP__='(-1021)' -D__UINT_LEAST16_MAX__='65535' -D__ATOMIC_ACQUIRE='2' -D__FLT_MIN__='1.17549435082228750797e-38F' -D__UINT_LEAST8_TYPE__='unsigned char' -D__INTMAX_C(c)='c ## L' -D__CHAR_BIT__='8' -D__UINT8_MAX__='255' -D__WINT_MAX__='4294967295U' -D__ORDER_LITTLE_ENDIAN__='1234' -D__SIZE_MAX__='18446744073709551615UL' -D__WCHAR_MAX__='2147483647' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_1='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_2='1' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_4='1' -D__DBL_DENORM_MIN__='double(4.94065645841246544177e-324L)' -D__GCC_HAVE_SYNC_COMPARE_AND_SWAP_8='1' -D__GCC_ATOMIC_CHAR_LOCK_FREE='2' -D__FLT_EVAL_METHOD__='0' -D__unix__='1' -D__GCC_ATOMIC_CHAR32_T_LOCK_FREE='2' -D__x86_64='1' -D__UINT_FAST64_MAX__='18446744073709551615UL' -D__SIG_ATOMIC_TYPE__='int' -D__DBL_MIN_10_EXP__='(-307)' -D__FINITE_MATH_ONLY__='0' -D__GNUC_PATCHLEVEL__='2' -D__UINT_FAST8_MAX__='255' -D__DEC64_MAX_EXP__='385' -D__INT8_C(c)='c' -D__UINT_LEAST64_MAX__='18446744073709551615UL' -D__SHRT_MAX__='32767' -D__LDBL_MAX__='1.18973149535723176502e+4932L' -D__UINT_LEAST8_MAX__='255' -D__GCC_ATOMIC_BOOL_LOCK_FREE='2' -D__UINTMAX_TYPE__='long unsigned int' -D__linux='1' -D__DEC32_EPSILON__='1E-6DF' -D__unix='1' -D__UINT32_MAX__='4294967295U' -D__LDBL_MAX_EXP__='16384' -D__WINT_MIN__='0U' -D__linux__='1' -D__SCHAR_MAX__='127' -D__WCHAR_MIN__='(-__WCHAR_MAX__ - 1)' -D__INT64_C(c)='c ## L' -D__DBL_DIG__='15' -D__GCC_ATOMIC_POINTER_LOCK_FREE='2' -D__SIZEOF_INT__='4' -D__SIZEOF_POINTER__='8' -D__GCC_ATOMIC_CHAR16_T_LOCK_FREE='2' -D__USER_LABEL_PREFIX__='' -D__STDC_HOSTED__='1' -D__LDBL_HAS_INFINITY__='1' -D__FLT_EPSILON__='1.19209289550781250000e-7F' -D__GXX_WEAK__='1' -D__LDBL_MIN__='3.36210314311209350626e-4932L' -D__DEC32_MAX__='9.999999E96DF' -D__INT32_MAX__='2147483647' -D__SIZEOF_LONG__='8' -D__UINT16_C(c)='c' -D__DECIMAL_DIG__='21' -D__gnu_linux__='1' -D__LDBL_HAS_QUIET_NAN__='1' -D__GNUC__='4' -D__GXX_RTTI='1' -D__MMX__='1' -D__FLT_HAS_DENORM__='1' -D__SIZEOF_LONG_DOUBLE__='16' -D__BIGGEST_ALIGNMENT__='16' -D__DBL_MAX__='double(1.79769313486231570815e+308L)' -D__INT_FAST32_MAX__='9223372036854775807L' -D__DBL_HAS_INFINITY__='1' -D__INT64_MAX__='9223372036854775807L' -D__DEC32_MIN_EXP__='(-94)' -D__INT_FAST16_TYPE__='long int' -D__LDBL_HAS_DENORM__='1' -D__cplusplus='199711L' -D__DEC128_MAX__='9.999999999999999999999999999999999E6144DL' -D__INT_LEAST32_MAX__='2147483647' -D__DEC32_MIN__='1E-95DF' -D__DEPRECATED='1' -D__DBL_MAX_EXP__='1024' -D__DEC128_EPSILON__='1E-33DL' -D__SSE2_MATH__='1' -D__PTRDIFF_MAX__='9223372036854775807L' -D__amd64='1' -D__GNUG__='4' -D__LONG_LONG_MAX__='9223372036854775807LL' -D__SIZEOF_SIZE_T__='8' -D__SIZEOF_WINT_T__='4' -D__GCC_HAVE_DWARF2_CFI_ASM='1' -D__GXX_ABI_VERSION='1002' -D__FLT_MIN_EXP__='(-125)' -D__INT_FAST64_TYPE__='long int' -D__DBL_MIN__='double(2.22507385850720138309e-308L)' -D__LP64__='1' -D__DECIMAL_BID_FORMAT__='1' -D__DEC128_MIN__='1E-6143DL' -D__REGISTER_PREFIX__='' -D__UINT16_MAX__='65535' -D__DBL_HAS_DENORM__='1' -D__UINT8_TYPE__='unsigned char' -D__NO_INLINE__='1' -D__FLT_MANT_DIG__='24' -D__VERSION__='"4.7.2"' -D__UINT64_C(c)='c ## UL' -D__GCC_ATOMIC_INT_LOCK_FREE='2' -D__FLOAT_WORD_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__INT32_C(c)='c' -D__DEC64_EPSILON__='1E-15DD' -D__ORDER_PDP_ENDIAN__='3412' -D__DEC128_MIN_EXP__='(-6142)' -D__INT_FAST32_TYPE__='long int' -D__UINT_LEAST16_TYPE__='short unsigned int' -Dunix='1' -D__INT16_MAX__='32767' -D__SIZE_TYPE__='long unsigned int' -D__UINT64_MAX__='18446744073709551615UL' -D__INT8_TYPE__='signed char' -D__ELF__='1' -D__FLT_RADIX__='2' -D__INT_LEAST16_TYPE__='short int' -D__LDBL_EPSILON__='1.08420217248550443401e-19L' -D__UINTMAX_C(c)='c ## UL' -D__k8='1' -D__SIG_ATOMIC_MAX__='2147483647' -D__GCC_ATOMIC_WCHAR_T_LOCK_FREE='2' -D__SIZEOF_PTRDIFF_T__='8' -D__x86_64__='1' -D__DEC32_SUBNORMAL_MIN__='0.000001E-95DF' -D__INT_FAST16_MAX__='9223372036854775807L' -D__UINT_FAST32_MAX__='18446744073709551615UL' -D__UINT_LEAST64_TYPE__='long unsigned int' -D__FLT_HAS_QUIET_NAN__='1' -D__FLT_MAX_10_EXP__='38' -D__LONG_MAX__='9223372036854775807L' -D__DEC128_SUBNORMAL_MIN__='0.000000000000000000000000000000001E-6143DL' -D__FLT_HAS_INFINITY__='1' -D__UINT_FAST16_TYPE__='long unsigned int' -D__DEC64_MAX__='9.999999999999999E384DD' -D__CHAR16_TYPE__='short unsigned int' -D__PRAGMA_REDEFINE_EXTNAME='1' -D__INT_LEAST16_MAX__='32767' -D__DEC64_MANT_DIG__='16' -D__UINT_LEAST32_MAX__='4294967295U' -D__GCC_ATOMIC_LONG_LOCK_FREE='2' -D__INT_LEAST64_TYPE__='long int' -D__INT16_TYPE__='short int' -D__INT_LEAST8_TYPE__='signed char' -D__DEC32_MAX_EXP__='97' -D__INT_FAST8_MAX__='127' -D__INTPTR_MAX__='9223372036854775807L' -Dlinux='1' -D__SSE2__='1' -D__EXCEPTIONS='1' -D__LDBL_MANT_DIG__='64' -D__DBL_HAS_QUIET_NAN__='1' -D__SIG_ATOMIC_MIN__='(-__SIG_ATOMIC_MAX__ - 1)' -D__k8__='1' -D__INTPTR_TYPE__='long int' -D__UINT16_TYPE__='short unsigned int' -D__WCHAR_TYPE__='int' -D__SIZEOF_FLOAT__='4' -D__UINTPTR_MAX__='18446744073709551615UL' -D__DEC64_MIN_EXP__='(-382)' -D__INT_FAST64_MAX__='9223372036854775807L' -D__GCC_ATOMIC_TEST_AND_SET_TRUEVAL='1' -D__FLT_DIG__='6' -D__UINT_FAST64_TYPE__='long unsigned int' -D__INT_MAX__='2147483647' -D__amd64__='1' -D__INT64_TYPE__='long int' -D__FLT_MAX_EXP__='128' -D__ORDER_BIG_ENDIAN__='4321' -D__DBL_MANT_DIG__='53' -D__INT_LEAST64_MAX__='9223372036854775807L' -D__DEC64_MIN__='1E-383DD' -D__WINT_TYPE__='unsigned int' -D__UINT_LEAST32_TYPE__='unsigned int' -D__SIZEOF_SHORT__='2' -D__SSE__='1' -D__LDBL_MIN_EXP__='(-16381)' -D__INT_LEAST8_MAX__='127' -D__SIZEOF_INT128__='16' -D__LDBL_MAX_10_EXP__='4932' -D__ATOMIC_RELAXED='0' -D__DBL_EPSILON__='double(2.22044604925031308085e-16L)' -D_LP64='1' -D__UINT8_C(c)='c' -D__INT_LEAST32_TYPE__='int' -D__SIZEOF_WCHAR_T__='4' -D__UINT64_TYPE__='long unsigned int' -D__INT_FAST8_TYPE__='signed char' -D__DBL_DECIMAL_DIG__='17' -D__DEC_EVAL_METHOD__='2' -D__UINT32_C(c)='c ## U' -D__INTMAX_MAX__='9223372036854775807L' -D__BYTE_ORDER__='__ORDER_LITTLE_ENDIAN__' -D__FLT_DENORM_MIN__='1.40129846432481707092e-45F' -D__INT8_MAX__='127' -D__UINT_FAST32_TYPE__='long unsigned int' -D__CHAR32_TYPE__='unsigned int' -D__FLT_MAX__='3.40282346638528859812e+38F' -D__INT32_TYPE__='int' -D__SIZEOF_DOUBLE__='8' -D__INTMAX_TYPE__='long int' -D__DEC128_MAX_EXP__='6145' -D__ATOMIC_CONSUME='1' -D__GNUC_MINOR__='7' -D__UINTMAX_MAX__='18446744073709551615UL' -D__DEC32_MANT_DIG__='7' -D__DBL_MAX_10_EXP__='308' -D__LDBL_DENORM_MIN__='3.64519953188247460253e-4951L' -D__INT16_C(c)='c' -D__STDC__='1' -D__PTRDIFF_TYPE__='long int' -D__ATOMIC_SEQ_CST='5' -D__UINT32_TYPE__='unsigned int' -D__UINTPTR_TYPE__='long unsigned int' -D__DEC64_SUBNORMAL_MIN__='0.000000000000001E-383DD' -D__DEC128_MANT_DIG__='34' -D__LDBL_MIN_10_EXP__='(-4931)' -D__SSE_MATH__='1' -D__SIZEOF_LONG_LONG__='8' -D__GCC_ATOMIC_LLONG_LOCK_FREE='2' -D__LDBL_DIG__='18' -D__FLT_DECIMAL_DIG__='9' -D__UINT_FAST16_MAX__='18446744073709551615UL' -D__GNUC_GNU_INLINE__='1' -D__FLT_MIN_10_EXP__='(-37)' -D__GCC_ATOMIC_SHORT_LOCK_FREE='2' -D__UINT_FAST8_TYPE__='unsigned char' -D_GNU_SOURCE='1' -D__ATOMIC_ACQ_REL='4' -D__ATOMIC_RELEASE='3' -iwrapper"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms3/share/gccxml-0.9/GCC/4.7" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/x86_64-unknown-linux-gnu" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/../../../../include/c++/4.7.2/backward" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/x86_64-unknown-linux-gnu/4.7.2/include-fixed" -isystem"/usr/local/include" -isystem"/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gcc/4.7.2-cms/bin/../lib/gcc/../../include" -isystem"/usr/include" -include "gccxml_builtins.h""
  GCCXML_USER_FLAGS=""
  GCCXML_ROOT="/cvmfs/cms.cern.ch/slc6_amd64_gcc472/external/gccxml/20110825-cms3/share/gccxml-0.9"

Compiler info:
c++ (GCC) 4.7.2
Copyright (C) 2012 Free Software Foundation, Inc.
This is free software; see the source for copying conditions.  There is NO
warranty; not even for MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.

*/

#ifdef _WIN32
#pragma warning ( disable : 4786 )
#pragma warning ( disable : 4345 )
#elif defined(__GNUC__) && (__GNUC__ > 4 || (__GNUC__ == 4 && __GNUC_MINOR__ >= 3)) && !defined(__INTEL_COMPILER) 
# pragma GCC diagnostic ignored "-Warray-bounds"
#endif
#include "/gpfs22/home/xuq7/HI/CMSSW_5_3_20/src/DataFormats/HeavyIonEvent/src/classes.h"
#ifdef CONST
# undef CONST
#endif
#include "Reflex/Builder/ReflexBuilder.h"
#include <typeinfo>

namespace {
  ::Reflex::NamespaceBuilder nsb0( Reflex::Literal("std") );
  ::Reflex::NamespaceBuilder nsb1( Reflex::Literal("edm") );
  ::Reflex::NamespaceBuilder nsb2( Reflex::Literal("reco") );
  ::Reflex::NamespaceBuilder nsb3( Reflex::Literal("pat") );
  ::Reflex::Type type_68 = ::Reflex::TypeBuilder(Reflex::Literal("int"));
  ::Reflex::Type type_271 = ::Reflex::TypeBuilder(Reflex::Literal("long"));
  ::Reflex::Type type_void = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_1439 = ::Reflex::TypeBuilder(Reflex::Literal("bool"));
  ::Reflex::Type type_1236 = ::Reflex::TypeBuilder(Reflex::Literal("void"));
  ::Reflex::Type type_102 = ::Reflex::TypeBuilder(Reflex::Literal("double"));
  ::Reflex::Type type_297 = ::Reflex::TypeBuilder(Reflex::Literal("unsigned long"));
  ::Reflex::Type type_6508 = ::Reflex::TypeBuilder(Reflex::Literal("pat::HeavyIon"));
  ::Reflex::Type type_429 = ::Reflex::TypeBuilder(Reflex::Literal("std::type_info"));
  ::Reflex::Type type_4215 = ::Reflex::TypeBuilder(Reflex::Literal("edm::ProductID"));
  ::Reflex::Type type_5968 = ::Reflex::TypeBuilder(Reflex::Literal("reco::EvtPlane"));
  ::Reflex::Type type_5969 = ::Reflex::TypeBuilder(Reflex::Literal("reco::Centrality"));
  ::Reflex::Type type_2286 = ::Reflex::TypeBuilder(Reflex::Literal("std::basic_string<char>"));
  ::Reflex::Type type_2706 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<const void*>"));
  ::Reflex::Type type_2707 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<unsigned long>"));
  ::Reflex::Type type_2725 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::EvtPlane>"));
  ::Reflex::Type type_4151 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<pat::HeavyIon>"));
  ::Reflex::Type type_2486 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<pat::HeavyIon>"));
  ::Reflex::Type type_4155 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::EvtPlane>"));
  ::Reflex::Type type_2726 = ::Reflex::TypeBuilder(Reflex::Literal("std::vector<reco::Centrality>"));
  ::Reflex::Type type_2490 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::EvtPlane>"));
  ::Reflex::Type type_2973 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::EvtPlane>"));
  ::Reflex::Type type_4154 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<reco::Centrality>"));
  ::Reflex::Type type_2489 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<reco::Centrality>"));
  ::Reflex::Type type_2974 = ::Reflex::TypeBuilder(Reflex::Literal("std::allocator<reco::Centrality>"));
  ::Reflex::Type type_4184 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<pat::HeavyIon>"));
  ::Reflex::Type type_4188 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::EvtPlane>"));
  ::Reflex::Type type_4187 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<reco::Centrality>"));
  ::Reflex::Type type_4152 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::EvtPlane> >"));
  ::Reflex::Type type_2487 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::EvtPlane> >"));
  ::Reflex::Type type_4153 = ::Reflex::TypeBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::Centrality> >"));
  ::Reflex::Type type_2488 = ::Reflex::TypeBuilder(Reflex::Literal("std::auto_ptr<std::vector<reco::Centrality> >"));
  ::Reflex::Type type_4185 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::EvtPlane> >"));
  ::Reflex::Type type_4186 = ::Reflex::TypeBuilder(Reflex::Literal("edm::WrapperInterface<std::vector<reco::Centrality> >"));
  ::Reflex::Type type_3908 = ::Reflex::TypeBuilder(Reflex::Literal("boost::shared_ptr<edm::reftobase::RefVectorHolderBase>"));
  ::Reflex::Type type_4870 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<reco::EvtPlane> >"));
  ::Reflex::Type type_4871 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__alloc_traits<std::allocator<reco::Centrality> >"));
  ::Reflex::Type type_2274 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::EvtPlane,std::allocator<reco::EvtPlane> >"));
  ::Reflex::Type type_2275 = ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::Centrality,std::allocator<reco::Centrality> >"));
  ::Reflex::Type type_4798 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> >"));
  ::Reflex::Type type_4800 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> >"));
  ::Reflex::Type type_4799 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::EvtPlane*,std::vector<reco::EvtPlane> >"));
  ::Reflex::Type type_4801 = ::Reflex::TypeBuilder(Reflex::Literal("__gnu_cxx::__normal_iterator<const reco::Centrality*,std::vector<reco::Centrality> >"));
  ::Reflex::Type type_3095 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> > >"));
  ::Reflex::Type type_3097 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> > >"));
  ::Reflex::Type type_3094 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::EvtPlane*,std::vector<reco::EvtPlane> > >"));
  ::Reflex::Type type_3096 = ::Reflex::TypeBuilder(Reflex::Literal("std::reverse_iterator<__gnu_cxx::__normal_iterator<const reco::Centrality*,std::vector<reco::Centrality> > >"));
  ::Reflex::Type type_5970 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::CentralityCollection"), type_2726);
  ::Reflex::Type type_5971 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("reco::EvtPlaneCollection"), type_2725);
  ::Reflex::Type type_26307 = ::Reflex::ReferenceBuilder(type_6508);
  ::Reflex::Type type_6508c = ::Reflex::ConstBuilder(type_6508);
  ::Reflex::Type type_26308 = ::Reflex::ReferenceBuilder(type_6508c);
  ::Reflex::Type type_5970c = ::Reflex::ConstBuilder(type_5970);
  ::Reflex::Type type_26309 = ::Reflex::ReferenceBuilder(type_5970c);
  ::Reflex::Type type_5971c = ::Reflex::ConstBuilder(type_5971);
  ::Reflex::Type type_26310 = ::Reflex::ReferenceBuilder(type_5971c);
  ::Reflex::Type type_25652 = ::Reflex::PointerBuilder(type_6508c);
  ::Reflex::Type type_429c = ::Reflex::ConstBuilder(type_429);
  ::Reflex::Type type_5966 = ::Reflex::ReferenceBuilder(type_429c);
  ::Reflex::Type type_25653 = ::Reflex::PointerBuilder(type_6508);
  ::Reflex::Type type_4184c = ::Reflex::ConstBuilder(type_4184);
  ::Reflex::Type type_25654 = ::Reflex::PointerBuilder(type_4184c);
  ::Reflex::Type type_4215c = ::Reflex::ConstBuilder(type_4215);
  ::Reflex::Type type_16806 = ::Reflex::ReferenceBuilder(type_4215c);
  ::Reflex::Type type_21493 = ::Reflex::ReferenceBuilder(type_2706);
  ::Reflex::Type type_25599 = ::Reflex::ReferenceBuilder(type_3908);
  ::Reflex::Type type_1236c = ::Reflex::ConstBuilder(type_1236);
  ::Reflex::Type type_3334 = ::Reflex::PointerBuilder(type_1236c);
  ::Reflex::Type type_7588 = ::Reflex::ReferenceBuilder(type_3334);
  ::Reflex::Type type_2707c = ::Reflex::ConstBuilder(type_2707);
  ::Reflex::Type type_21494 = ::Reflex::ReferenceBuilder(type_2707c);
  ::Reflex::Type type_2287 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::string"), type_2286);
  ::Reflex::Type type_10863 = ::Reflex::ReferenceBuilder(type_5969);
  ::Reflex::Type type_5969c = ::Reflex::ConstBuilder(type_5969);
  ::Reflex::Type type_10865 = ::Reflex::ReferenceBuilder(type_5969c);
  ::Reflex::Type type_10861 = ::Reflex::PointerBuilder(type_5969c);
  ::Reflex::Type type_7129 = ::Reflex::PointerBuilder(type_5969);
  ::Reflex::Type type_4187c = ::Reflex::ConstBuilder(type_4187);
  ::Reflex::Type type_25667 = ::Reflex::PointerBuilder(type_4187c);
  ::Reflex::Type type_10798 = ::Reflex::ReferenceBuilder(type_5968);
  ::Reflex::Type type_5968c = ::Reflex::ConstBuilder(type_5968);
  ::Reflex::Type type_10800 = ::Reflex::ReferenceBuilder(type_5968c);
  ::Reflex::Type type_10796 = ::Reflex::PointerBuilder(type_5968c);
  ::Reflex::Type type_7110 = ::Reflex::PointerBuilder(type_5968);
  ::Reflex::Type type_4188c = ::Reflex::ConstBuilder(type_4188);
  ::Reflex::Type type_25670 = ::Reflex::PointerBuilder(type_4188c);
  ::Reflex::Type type_2924 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::size_t"), type_297);
  ::Reflex::Type type_2823 = ::Reflex::TypedefTypeBuilder(Reflex::Literal("std::ptrdiff_t"), type_271);
  ::Reflex::Type type_2974c = ::Reflex::ConstBuilder(type_2974);
  ::Reflex::Type type_20965 = ::Reflex::ReferenceBuilder(type_2974c);
  ::Reflex::Type type_2726c = ::Reflex::ConstBuilder(type_2726);
  ::Reflex::Type type_21539 = ::Reflex::ReferenceBuilder(type_2726c);
  ::Reflex::Type type_21540 = ::Reflex::ReferenceBuilder(type_2726);
  ::Reflex::Type type_2973c = ::Reflex::ConstBuilder(type_2973);
  ::Reflex::Type type_20952 = ::Reflex::ReferenceBuilder(type_2973c);
  ::Reflex::Type type_2725c = ::Reflex::ConstBuilder(type_2725);
  ::Reflex::Type type_21536 = ::Reflex::ReferenceBuilder(type_2725c);
  ::Reflex::Type type_21537 = ::Reflex::ReferenceBuilder(type_2725);
  ::Reflex::Type type_25657 = ::Reflex::PointerBuilder(type_2725c);
  ::Reflex::Type type_25658 = ::Reflex::PointerBuilder(type_2725);
  ::Reflex::Type type_4185c = ::Reflex::ConstBuilder(type_4185);
  ::Reflex::Type type_25659 = ::Reflex::PointerBuilder(type_4185c);
  ::Reflex::Type type_25662 = ::Reflex::PointerBuilder(type_2726c);
  ::Reflex::Type type_25663 = ::Reflex::PointerBuilder(type_2726);
  ::Reflex::Type type_4186c = ::Reflex::ConstBuilder(type_4186);
  ::Reflex::Type type_25664 = ::Reflex::PointerBuilder(type_4186c);
  ::Reflex::Type type_4152f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::EvtPlaneCollection>"), type_4152);
  ::Reflex::Type type_4153f = ::Reflex::TypedefTypeBuilder(Reflex::Literal("edm::Wrapper<reco::CentralityCollection>"), type_4153);
} // unnamed namespace

#ifndef __CINT__

// Shadow classes to obtain the data member offsets 
namespace __shadow__ {
#ifdef __pat__HeavyIon
#undef __pat__HeavyIon
#endif
class __pat__HeavyIon {
  public:
  __pat__HeavyIon();
  virtual ~__pat__HeavyIon() throw();
  ::reco::CentralityCollection cents_;
  ::reco::EvtPlaneCollection planes_;
  bool isMC_;
  double b_;
  int npart_;
  int ncoll_;
  int nhard_;
  double phi_;
};
#ifdef __edm__Wrapper_pat__HeavyIon_
#undef __edm__Wrapper_pat__HeavyIon_
#endif
class __edm__Wrapper_pat__HeavyIon_ {
  public:
  __edm__Wrapper_pat__HeavyIon_();
  bool present;
  ::pat::HeavyIon obj;
};
#ifdef __reco__Centrality
#undef __reco__Centrality
#endif
class __reco__Centrality {
  public:
  __reco__Centrality();
  virtual ~__reco__Centrality() throw();
  double value_;
  ::std::string label_;
  double etHFhitSumPlus_;
  double etHFtowerSumPlus_;
  double etHFtruncatedPlus_;
  double etHFhitSumMinus_;
  double etHFtowerSumMinus_;
  double etHFtruncatedMinus_;
  double etEESumPlus_;
  double etEEtruncatedPlus_;
  double etEESumMinus_;
  double etEEtruncatedMinus_;
  double etEBSum_;
  double etEBtruncated_;
  double pixelMultiplicity_;
  double trackMultiplicity_;
  double zdcSumPlus_;
  double zdcSumMinus_;
  double etMidRapiditySum_;
  double ntracksPtCut_;
  double ntracksEtaCut_;
  double ntracksEtaPtCut_;
  double nPixelTracks_;
};
#ifdef __edm__Wrapper_reco__Centrality_
#undef __edm__Wrapper_reco__Centrality_
#endif
class __edm__Wrapper_reco__Centrality_ {
  public:
  __edm__Wrapper_reco__Centrality_();
  bool present;
  ::reco::Centrality obj;
};
#ifdef __reco__EvtPlane
#undef __reco__EvtPlane
#endif
class __reco__EvtPlane {
  public:
  __reco__EvtPlane();
  virtual ~__reco__EvtPlane() throw();
  double angle_;
  double sumSin_;
  double sumCos_;
  ::std::string label_;
};
#ifdef __edm__Wrapper_reco__EvtPlane_
#undef __edm__Wrapper_reco__EvtPlane_
#endif
class __edm__Wrapper_reco__EvtPlane_ {
  public:
  __edm__Wrapper_reco__EvtPlane_();
  bool present;
  ::reco::EvtPlane obj;
};
#ifdef __std__vector_reco__Centrality_
#undef __std__vector_reco__Centrality_
#endif
class __std__vector_reco__Centrality_ : protected ::std::_Vector_base<reco::Centrality,std::allocator<reco::Centrality> > {
  public:
  __std__vector_reco__Centrality_();
};
#ifdef __std__vector_reco__EvtPlane_
#undef __std__vector_reco__EvtPlane_
#endif
class __std__vector_reco__EvtPlane_ : protected ::std::_Vector_base<reco::EvtPlane,std::allocator<reco::EvtPlane> > {
  public:
  __std__vector_reco__EvtPlane_();
};
#ifdef __edm__Wrapper_std__vector_reco__EvtPlane_s_
#undef __edm__Wrapper_std__vector_reco__EvtPlane_s_
#endif
class __edm__Wrapper_std__vector_reco__EvtPlane_s_ {
  public:
  __edm__Wrapper_std__vector_reco__EvtPlane_s_();
  bool present;
  ::std::vector<reco::EvtPlane> obj;
};
#ifdef __edm__Wrapper_std__vector_reco__Centrality_s_
#undef __edm__Wrapper_std__vector_reco__Centrality_s_
#endif
class __edm__Wrapper_std__vector_reco__Centrality_s_ {
  public:
  __edm__Wrapper_std__vector_reco__Centrality_s_();
  bool present;
  ::std::vector<reco::Centrality> obj;
};
}


#endif // __CINT__
namespace {
//------Stub functions for class HeavyIon -------------------------------
static  void operator_20452( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::pat::HeavyIon*)o)->operator=)(*(const ::pat::HeavyIon*)arg[0]);
  else   (((::pat::HeavyIon*)o)->operator=)(*(const ::pat::HeavyIon*)arg[0]);
}

static void constructor_20453( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::HeavyIon(*(const ::pat::HeavyIon*)arg[0]);
  else ::new(mem) ::pat::HeavyIon(*(const ::pat::HeavyIon*)arg[0]);
}

static void constructor_20454( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::HeavyIon();
  else ::new(mem) ::pat::HeavyIon();
}

static void constructor_20455( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::HeavyIon(*(const ::reco::CentralityCollection*)arg[0],
      *(const ::reco::EvtPlaneCollection*)arg[1]);
  else ::new(mem) ::pat::HeavyIon(*(const ::reco::CentralityCollection*)arg[0],
      *(const ::reco::EvtPlaneCollection*)arg[1]);
}

static void constructor_20456( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::pat::HeavyIon(*(const ::reco::CentralityCollection*)arg[0],
      *(const ::reco::EvtPlaneCollection*)arg[1],
      *(double*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6]);
  else ::new(mem) ::pat::HeavyIon(*(const ::reco::CentralityCollection*)arg[0],
      *(const ::reco::EvtPlaneCollection*)arg[1],
      *(double*)arg[2],
      *(int*)arg[3],
      *(int*)arg[4],
      *(int*)arg[5],
      *(double*)arg[6]);
}

static void destructor_20457(void*, void * o, const std::vector<void*>&, void *) {
(((::pat::HeavyIon*)o)->::pat::HeavyIon::~HeavyIon)();
}
static  void method_20458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::pat::HeavyIon*)o)->getCentralityCollection)();
  else   (((const ::pat::HeavyIon*)o)->getCentralityCollection)();
}

static  void method_20459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::pat::HeavyIon*)o)->isMC)());
  else   (((const ::pat::HeavyIon*)o)->isMC)();
}

static  void method_20460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::HeavyIon*)o)->generatedB)());
  else   (((const ::pat::HeavyIon*)o)->generatedB)();
}

static  void method_20461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::HeavyIon*)o)->generatedNpart)());
  else   (((const ::pat::HeavyIon*)o)->generatedNpart)();
}

static  void method_20462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::HeavyIon*)o)->generatedNcoll)());
  else   (((const ::pat::HeavyIon*)o)->generatedNcoll)();
}

static  void method_20463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (int)((((const ::pat::HeavyIon*)o)->generatedNhard)());
  else   (((const ::pat::HeavyIon*)o)->generatedNhard)();
}

static  void method_20464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::pat::HeavyIon*)o)->generatedEvtPlane)());
  else   (((const ::pat::HeavyIon*)o)->generatedEvtPlane)();
}

static void method_newdel_6508( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::pat::HeavyIon >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::pat::HeavyIon >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::pat::HeavyIon >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::pat::HeavyIon >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::pat::HeavyIon >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class HeavyIon -------------------------------
void __pat__HeavyIon_db_datamem(Reflex::Class*);
void __pat__HeavyIon_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __pat__HeavyIon_datamem_bld(&__pat__HeavyIon_db_datamem);
Reflex::GenreflexMemberBuilder __pat__HeavyIon_funcmem_bld(&__pat__HeavyIon_db_funcmem);
void __pat__HeavyIon_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("pat::HeavyIon"), typeid(::pat::HeavyIon), sizeof(::pat::HeavyIon), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26307, type_26308), Reflex::Literal("operator="), operator_20452, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26308), Reflex::Literal("HeavyIon"), constructor_20453, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("HeavyIon"), constructor_20454, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26309, type_26310), Reflex::Literal("HeavyIon"), constructor_20455, 0, "c;e", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_26309, type_26310, type_102, type_68, type_68, type_68, type_102), Reflex::Literal("HeavyIon"), constructor_20456, 0, "c;e;b;npart;ncoll;nhard;phi", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~HeavyIon"), destructor_20457, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_6508, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__pat__HeavyIon_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__pat__HeavyIon_funcmem_bld);
}

//------Delayed data member builder for class HeavyIon -------------------
void __pat__HeavyIon_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_5970, Reflex::Literal("cents_"), OffsetOf(__shadow__::__pat__HeavyIon, cents_), ::Reflex::PRIVATE)
  .AddDataMember(type_5971, Reflex::Literal("planes_"), OffsetOf(__shadow__::__pat__HeavyIon, planes_), ::Reflex::PRIVATE)
  .AddDataMember(type_1439, Reflex::Literal("isMC_"), OffsetOf(__shadow__::__pat__HeavyIon, isMC_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("b_"), OffsetOf(__shadow__::__pat__HeavyIon, b_), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("npart_"), OffsetOf(__shadow__::__pat__HeavyIon, npart_), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("ncoll_"), OffsetOf(__shadow__::__pat__HeavyIon, ncoll_), ::Reflex::PRIVATE)
  .AddDataMember(type_68, Reflex::Literal("nhard_"), OffsetOf(__shadow__::__pat__HeavyIon, nhard_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("phi_"), OffsetOf(__shadow__::__pat__HeavyIon, phi_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class HeavyIon -------------------
void __pat__HeavyIon_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_26309), Reflex::Literal("getCentralityCollection"), method_20458, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1439), Reflex::Literal("isMC"), method_20459, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("generatedB"), method_20460, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("generatedNpart"), method_20461, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("generatedNcoll"), method_20462, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_68), Reflex::Literal("generatedNhard"), method_20463, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("generatedEvtPlane"), method_20464, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<pat::HeavyIon> -------------------------------
static void constructor_16641( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<pat::HeavyIon>();
  else ::new(mem) ::edm::Wrapper<pat::HeavyIon>();
}

static void constructor_16642( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<pat::HeavyIon>(*(::std::auto_ptr<pat::HeavyIon>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<pat::HeavyIon>(*(::std::auto_ptr<pat::HeavyIon>*)arg[0]);
}

static void destructor_16643(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<pat::HeavyIon>*)o)->::edm::Wrapper<pat::HeavyIon>::~Wrapper)();
}
static  void method_16644( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<pat::HeavyIon>*)o)->product)());
  else   (((const ::edm::Wrapper<pat::HeavyIon>*)o)->product)();
}

static  void operator_16645( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<pat::HeavyIon>*)o)->operator->)());
  else   (((const ::edm::Wrapper<pat::HeavyIon>*)o)->operator->)();
}

static  void method_16646( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<pat::HeavyIon>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<pat::HeavyIon>*)o)->productTypeInfo)();
}

static  void method_16647( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<pat::HeavyIon>*)o)->typeInfo)();
  else   (((::edm::Wrapper<pat::HeavyIon>*)o)->typeInfo)();
}

static void constructor_16648( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<pat::HeavyIon>((::pat::HeavyIon*)arg[0]);
  else ::new(mem) ::edm::Wrapper<pat::HeavyIon>((::pat::HeavyIon*)arg[0]);
}

static  void method_16649( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<pat::HeavyIon>*)o)->getInterface)());
  else   (((::edm::Wrapper<pat::HeavyIon>*)o)->getInterface)();
}

static  void method_16650( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<pat::HeavyIon>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16651( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<pat::HeavyIon>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16652( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<pat::HeavyIon>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16653( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<pat::HeavyIon>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<pat::HeavyIon>*)o)->dynamicTypeInfo)();
}

static  void method_16654( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<pat::HeavyIon>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<pat::HeavyIon>*)o)->isPresent)();
}

static  void method_16655( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<pat::HeavyIon>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<pat::HeavyIon>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4151( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<pat::HeavyIon> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<pat::HeavyIon> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<pat::HeavyIon> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<pat::HeavyIon> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<pat::HeavyIon> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<pat::HeavyIon> -------------------------------
void __edm__Wrapper_pat__HeavyIon__db_datamem(Reflex::Class*);
void __edm__Wrapper_pat__HeavyIon__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_pat__HeavyIon__datamem_bld(&__edm__Wrapper_pat__HeavyIon__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_pat__HeavyIon__funcmem_bld(&__edm__Wrapper_pat__HeavyIon__db_funcmem);
void __edm__Wrapper_pat__HeavyIon__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<pat::HeavyIon>"), typeid(::edm::Wrapper<pat::HeavyIon>), sizeof(::edm::Wrapper<pat::HeavyIon>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_6508, Reflex::Literal("edm::Wrapper<pat::HeavyIon>::value_type"))
  .AddTypedef(type_6508, Reflex::Literal("edm::Wrapper<pat::HeavyIon>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16641, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2486), Reflex::Literal("Wrapper"), constructor_16642, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16643, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25653), Reflex::Literal("Wrapper"), constructor_16648, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4151, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_pat__HeavyIon__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_pat__HeavyIon__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<pat::HeavyIon> -------------------
void __edm__Wrapper_pat__HeavyIon__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1439, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_pat__HeavyIon_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_6508, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_pat__HeavyIon_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<pat::HeavyIon> -------------------
void __edm__Wrapper_pat__HeavyIon__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25652), Reflex::Literal("product"), method_16644, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25652), Reflex::Literal("operator->"), operator_16645, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("productTypeInfo"), method_16646, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("typeInfo"), method_16647, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25654), Reflex::Literal("getInterface"), method_16649, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_16806, type_21493, type_25599), Reflex::Literal("fillView"), method_16650, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_5966, type_297, type_7588), Reflex::Literal("setPtr"), method_16651, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_5966, type_21494, type_21493), Reflex::Literal("fillPtrVector"), method_16652, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("dynamicTypeInfo"), method_16653, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1439), Reflex::Literal("isPresent"), method_16654, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("dynamicTypeInfo_"), method_16655, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Centrality -------------------------------
static  void operator_19433( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::Centrality*)o)->operator=)(*(const ::reco::Centrality*)arg[0]);
  else   (((::reco::Centrality*)o)->operator=)(*(const ::reco::Centrality*)arg[0]);
}

static void constructor_19434( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::Centrality(*(const ::reco::Centrality*)arg[0]);
  else ::new(mem) ::reco::Centrality(*(const ::reco::Centrality*)arg[0]);
}

static void constructor_19435( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::reco::Centrality();
  else ::new(mem) ::reco::Centrality();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::reco::Centrality(*(double*)arg[0]);
  else ::new(mem) ::reco::Centrality(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::reco::Centrality(*(double*)arg[0],
      *(::std::string*)arg[1]);
  else ::new(mem) ::reco::Centrality(*(double*)arg[0],
      *(::std::string*)arg[1]);
  }
}

static void destructor_19436(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::Centrality*)o)->::reco::Centrality::~Centrality)();
}
static  void method_19437( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->raw)());
  else   (((const ::reco::Centrality*)o)->raw)();
}

static  void method_19438( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::reco::Centrality*)o)->label)());
  else   (((const ::reco::Centrality*)o)->label)();
}

static  void method_19439( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtHFhitSum)());
  else   (((const ::reco::Centrality*)o)->EtHFhitSum)();
}

static  void method_19440( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtHFhitSumPlus)());
  else   (((const ::reco::Centrality*)o)->EtHFhitSumPlus)();
}

static  void method_19441( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtHFhitSumMinus)());
  else   (((const ::reco::Centrality*)o)->EtHFhitSumMinus)();
}

static  void method_19442( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtHFtowerSum)());
  else   (((const ::reco::Centrality*)o)->EtHFtowerSum)();
}

static  void method_19443( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtHFtowerSumPlus)());
  else   (((const ::reco::Centrality*)o)->EtHFtowerSumPlus)();
}

static  void method_19444( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtHFtowerSumMinus)());
  else   (((const ::reco::Centrality*)o)->EtHFtowerSumMinus)();
}

static  void method_19445( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtHFtruncated)());
  else   (((const ::reco::Centrality*)o)->EtHFtruncated)();
}

static  void method_19446( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtHFtruncatedPlus)());
  else   (((const ::reco::Centrality*)o)->EtHFtruncatedPlus)();
}

static  void method_19447( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtHFtruncatedMinus)());
  else   (((const ::reco::Centrality*)o)->EtHFtruncatedMinus)();
}

static  void method_19448( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtEESum)());
  else   (((const ::reco::Centrality*)o)->EtEESum)();
}

static  void method_19449( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtEESumPlus)());
  else   (((const ::reco::Centrality*)o)->EtEESumPlus)();
}

static  void method_19450( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtEESumMinus)());
  else   (((const ::reco::Centrality*)o)->EtEESumMinus)();
}

static  void method_19451( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtEEtruncated)());
  else   (((const ::reco::Centrality*)o)->EtEEtruncated)();
}

static  void method_19452( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtEEtruncatedPlus)());
  else   (((const ::reco::Centrality*)o)->EtEEtruncatedPlus)();
}

static  void method_19453( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtEEtruncatedMinus)());
  else   (((const ::reco::Centrality*)o)->EtEEtruncatedMinus)();
}

static  void method_19454( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtEBSum)());
  else   (((const ::reco::Centrality*)o)->EtEBSum)();
}

static  void method_19455( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtEBtruncated)());
  else   (((const ::reco::Centrality*)o)->EtEBtruncated)();
}

static  void method_19456( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtEcalSum)());
  else   (((const ::reco::Centrality*)o)->EtEcalSum)();
}

static  void method_19457( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtEcaltruncated)());
  else   (((const ::reco::Centrality*)o)->EtEcaltruncated)();
}

static  void method_19458( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->multiplicityPixel)());
  else   (((const ::reco::Centrality*)o)->multiplicityPixel)();
}

static  void method_19459( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->Ntracks)());
  else   (((const ::reco::Centrality*)o)->Ntracks)();
}

static  void method_19460( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->NtracksPtCut)());
  else   (((const ::reco::Centrality*)o)->NtracksPtCut)();
}

static  void method_19461( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->NtracksEtaCut)());
  else   (((const ::reco::Centrality*)o)->NtracksEtaCut)();
}

static  void method_19462( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->NtracksEtaPtCut)());
  else   (((const ::reco::Centrality*)o)->NtracksEtaPtCut)();
}

static  void method_19463( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->NpixelTracks)());
  else   (((const ::reco::Centrality*)o)->NpixelTracks)();
}

static  void method_19464( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->zdcSum)());
  else   (((const ::reco::Centrality*)o)->zdcSum)();
}

static  void method_19465( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->zdcSumPlus)());
  else   (((const ::reco::Centrality*)o)->zdcSumPlus)();
}

static  void method_19466( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->zdcSumMinus)());
  else   (((const ::reco::Centrality*)o)->zdcSumMinus)();
}

static  void method_19467( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::Centrality*)o)->EtMidRapiditySum)());
  else   (((const ::reco::Centrality*)o)->EtMidRapiditySum)();
}

static void constructor_x2( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::Centrality();
  else ::new(mem) ::reco::Centrality();
}

static void method_newdel_5969( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::Centrality >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::Centrality >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::Centrality >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::Centrality >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::Centrality >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Centrality -------------------------------
void __reco__Centrality_db_datamem(Reflex::Class*);
void __reco__Centrality_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__Centrality_datamem_bld(&__reco__Centrality_db_datamem);
Reflex::GenreflexMemberBuilder __reco__Centrality_funcmem_bld(&__reco__Centrality_db_funcmem);
void __reco__Centrality_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::Centrality"), typeid(::reco::Centrality), sizeof(::reco::Centrality), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10863, type_10865), Reflex::Literal("operator="), operator_19433, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10865), Reflex::Literal("Centrality"), constructor_19434, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_102, type_2287), Reflex::Literal("Centrality"), constructor_19435, 0, "d=0;label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Centrality"), destructor_19436, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Centrality"), constructor_x2, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5969, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__Centrality_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__Centrality_funcmem_bld);
}

//------Delayed data member builder for class Centrality -------------------
void __reco__Centrality_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_102, Reflex::Literal("value_"), OffsetOf(__shadow__::__reco__Centrality, value_), ::Reflex::PROTECTED)
  .AddDataMember(type_2287, Reflex::Literal("label_"), OffsetOf(__shadow__::__reco__Centrality, label_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("etHFhitSumPlus_"), OffsetOf(__shadow__::__reco__Centrality, etHFhitSumPlus_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("etHFtowerSumPlus_"), OffsetOf(__shadow__::__reco__Centrality, etHFtowerSumPlus_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("etHFtruncatedPlus_"), OffsetOf(__shadow__::__reco__Centrality, etHFtruncatedPlus_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("etHFhitSumMinus_"), OffsetOf(__shadow__::__reco__Centrality, etHFhitSumMinus_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("etHFtowerSumMinus_"), OffsetOf(__shadow__::__reco__Centrality, etHFtowerSumMinus_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("etHFtruncatedMinus_"), OffsetOf(__shadow__::__reco__Centrality, etHFtruncatedMinus_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("etEESumPlus_"), OffsetOf(__shadow__::__reco__Centrality, etEESumPlus_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("etEEtruncatedPlus_"), OffsetOf(__shadow__::__reco__Centrality, etEEtruncatedPlus_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("etEESumMinus_"), OffsetOf(__shadow__::__reco__Centrality, etEESumMinus_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("etEEtruncatedMinus_"), OffsetOf(__shadow__::__reco__Centrality, etEEtruncatedMinus_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("etEBSum_"), OffsetOf(__shadow__::__reco__Centrality, etEBSum_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("etEBtruncated_"), OffsetOf(__shadow__::__reco__Centrality, etEBtruncated_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("pixelMultiplicity_"), OffsetOf(__shadow__::__reco__Centrality, pixelMultiplicity_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("trackMultiplicity_"), OffsetOf(__shadow__::__reco__Centrality, trackMultiplicity_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("zdcSumPlus_"), OffsetOf(__shadow__::__reco__Centrality, zdcSumPlus_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("zdcSumMinus_"), OffsetOf(__shadow__::__reco__Centrality, zdcSumMinus_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("etMidRapiditySum_"), OffsetOf(__shadow__::__reco__Centrality, etMidRapiditySum_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("ntracksPtCut_"), OffsetOf(__shadow__::__reco__Centrality, ntracksPtCut_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("ntracksEtaCut_"), OffsetOf(__shadow__::__reco__Centrality, ntracksEtaCut_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("ntracksEtaPtCut_"), OffsetOf(__shadow__::__reco__Centrality, ntracksEtaPtCut_), ::Reflex::PROTECTED)
  .AddDataMember(type_102, Reflex::Literal("nPixelTracks_"), OffsetOf(__shadow__::__reco__Centrality, nPixelTracks_), ::Reflex::PROTECTED);
}
//------Delayed function member builder for class Centrality -------------------
void __reco__Centrality_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("raw"), method_19437, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2287), Reflex::Literal("label"), method_19438, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtHFhitSum"), method_19439, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtHFhitSumPlus"), method_19440, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtHFhitSumMinus"), method_19441, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtHFtowerSum"), method_19442, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtHFtowerSumPlus"), method_19443, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtHFtowerSumMinus"), method_19444, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtHFtruncated"), method_19445, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtHFtruncatedPlus"), method_19446, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtHFtruncatedMinus"), method_19447, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtEESum"), method_19448, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtEESumPlus"), method_19449, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtEESumMinus"), method_19450, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtEEtruncated"), method_19451, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtEEtruncatedPlus"), method_19452, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtEEtruncatedMinus"), method_19453, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtEBSum"), method_19454, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtEBtruncated"), method_19455, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtEcalSum"), method_19456, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtEcaltruncated"), method_19457, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("multiplicityPixel"), method_19458, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("Ntracks"), method_19459, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("NtracksPtCut"), method_19460, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("NtracksEtaCut"), method_19461, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("NtracksEtaPtCut"), method_19462, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("NpixelTracks"), method_19463, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("zdcSum"), method_19464, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("zdcSumPlus"), method_19465, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("zdcSumMinus"), method_19466, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("EtMidRapiditySum"), method_19467, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<reco::Centrality> -------------------------------
static void constructor_16704( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::Centrality>();
  else ::new(mem) ::edm::Wrapper<reco::Centrality>();
}

static void constructor_16705( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::Centrality>(*(::std::auto_ptr<reco::Centrality>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::Centrality>(*(::std::auto_ptr<reco::Centrality>*)arg[0]);
}

static void destructor_16706(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::Centrality>*)o)->::edm::Wrapper<reco::Centrality>::~Wrapper)();
}
static  void method_16707( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::Centrality>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::Centrality>*)o)->product)();
}

static  void operator_16708( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::Centrality>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::Centrality>*)o)->operator->)();
}

static  void method_16709( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::Centrality>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::Centrality>*)o)->productTypeInfo)();
}

static  void method_16710( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::Centrality>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::Centrality>*)o)->typeInfo)();
}

static void constructor_16711( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::Centrality>((::reco::Centrality*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::Centrality>((::reco::Centrality*)arg[0]);
}

static  void method_16712( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::Centrality>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::Centrality>*)o)->getInterface)();
}

static  void method_16713( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::Centrality>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16714( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::Centrality>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16715( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::Centrality>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16716( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::Centrality>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::Centrality>*)o)->dynamicTypeInfo)();
}

static  void method_16717( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::Centrality>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::Centrality>*)o)->isPresent)();
}

static  void method_16718( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::Centrality>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::Centrality>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4154( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::Centrality> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::Centrality> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::Centrality> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::Centrality> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::Centrality> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::Centrality> -------------------------------
void __edm__Wrapper_reco__Centrality__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__Centrality__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__Centrality__datamem_bld(&__edm__Wrapper_reco__Centrality__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__Centrality__funcmem_bld(&__edm__Wrapper_reco__Centrality__db_funcmem);
void __edm__Wrapper_reco__Centrality__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::Centrality>"), typeid(::edm::Wrapper<reco::Centrality>), sizeof(::edm::Wrapper<reco::Centrality>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_5969, Reflex::Literal("edm::Wrapper<reco::Centrality>::value_type"))
  .AddTypedef(type_5969, Reflex::Literal("edm::Wrapper<reco::Centrality>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16704, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2489), Reflex::Literal("Wrapper"), constructor_16705, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16706, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7129), Reflex::Literal("Wrapper"), constructor_16711, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4154, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__Centrality__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__Centrality__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::Centrality> -------------------
void __edm__Wrapper_reco__Centrality__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1439, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__Centrality_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_5969, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__Centrality_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::Centrality> -------------------
void __edm__Wrapper_reco__Centrality__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10861), Reflex::Literal("product"), method_16707, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10861), Reflex::Literal("operator->"), operator_16708, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("productTypeInfo"), method_16709, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("typeInfo"), method_16710, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25667), Reflex::Literal("getInterface"), method_16712, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_16806, type_21493, type_25599), Reflex::Literal("fillView"), method_16713, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_5966, type_297, type_7588), Reflex::Literal("setPtr"), method_16714, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_5966, type_21494, type_21493), Reflex::Literal("fillPtrVector"), method_16715, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("dynamicTypeInfo"), method_16716, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1439), Reflex::Literal("isPresent"), method_16717, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("dynamicTypeInfo_"), method_16718, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class EvtPlane -------------------------------
static  void operator_19402( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::reco::EvtPlane*)o)->operator=)(*(const ::reco::EvtPlane*)arg[0]);
  else   (((::reco::EvtPlane*)o)->operator=)(*(const ::reco::EvtPlane*)arg[0]);
}

static void constructor_19403( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::EvtPlane(*(const ::reco::EvtPlane*)arg[0]);
  else ::new(mem) ::reco::EvtPlane(*(const ::reco::EvtPlane*)arg[0]);
}

static void constructor_19404( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 0 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::reco::EvtPlane();
  else ::new(mem) ::reco::EvtPlane();
  }
  else if ( arg.size() == 1 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::reco::EvtPlane(*(double*)arg[0]);
  else ::new(mem) ::reco::EvtPlane(*(double*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::reco::EvtPlane(*(double*)arg[0],
      *(double*)arg[1]);
  else ::new(mem) ::reco::EvtPlane(*(double*)arg[0],
      *(double*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::reco::EvtPlane(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  else ::new(mem) ::reco::EvtPlane(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2]);
  }
  else if ( arg.size() == 4 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::reco::EvtPlane(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::std::string*)arg[3]);
  else ::new(mem) ::reco::EvtPlane(*(double*)arg[0],
      *(double*)arg[1],
      *(double*)arg[2],
      *(::std::string*)arg[3]);
  }
}

static void destructor_19405(void*, void * o, const std::vector<void*>&, void *) {
(((::reco::EvtPlane*)o)->::reco::EvtPlane::~EvtPlane)();
}
static  void method_19406( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::EvtPlane*)o)->angle)());
  else   (((const ::reco::EvtPlane*)o)->angle)();
}

static  void method_19407( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::EvtPlane*)o)->sumSin)());
  else   (((const ::reco::EvtPlane*)o)->sumSin)();
}

static  void method_19408( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (double)((((const ::reco::EvtPlane*)o)->sumCos)());
  else   (((const ::reco::EvtPlane*)o)->sumCos)();
}

static  void method_19409( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::string)((((const ::reco::EvtPlane*)o)->label)());
  else   (((const ::reco::EvtPlane*)o)->label)();
}

static void constructor_x5( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::reco::EvtPlane();
  else ::new(mem) ::reco::EvtPlane();
}

static void method_newdel_5968( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::reco::EvtPlane >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::reco::EvtPlane >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::reco::EvtPlane >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::reco::EvtPlane >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::reco::EvtPlane >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class EvtPlane -------------------------------
void __reco__EvtPlane_db_datamem(Reflex::Class*);
void __reco__EvtPlane_db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __reco__EvtPlane_datamem_bld(&__reco__EvtPlane_db_datamem);
Reflex::GenreflexMemberBuilder __reco__EvtPlane_funcmem_bld(&__reco__EvtPlane_db_funcmem);
void __reco__EvtPlane_dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("reco::EvtPlane"), typeid(::reco::EvtPlane), sizeof(::reco::EvtPlane), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::VIRTUAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("ClassVersion"), "10")
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10798, type_10800), Reflex::Literal("operator="), operator_19402, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_10800), Reflex::Literal("EvtPlane"), constructor_19403, 0, "", ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_102, type_102, type_102, type_2287), Reflex::Literal("EvtPlane"), constructor_19404, 0, "planeA=0;sumSin=0;sumCos=0;label=\"\"", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~EvtPlane"), destructor_19405, 0, 0, ::Reflex::PUBLIC | ::Reflex::VIRTUAL | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("EvtPlane"), constructor_x5, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_5968, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__reco__EvtPlane_datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__reco__EvtPlane_funcmem_bld);
}

//------Delayed data member builder for class EvtPlane -------------------
void __reco__EvtPlane_db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_102, Reflex::Literal("angle_"), OffsetOf(__shadow__::__reco__EvtPlane, angle_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("sumSin_"), OffsetOf(__shadow__::__reco__EvtPlane, sumSin_), ::Reflex::PRIVATE)
  .AddDataMember(type_102, Reflex::Literal("sumCos_"), OffsetOf(__shadow__::__reco__EvtPlane, sumCos_), ::Reflex::PRIVATE)
  .AddDataMember(type_2287, Reflex::Literal("label_"), OffsetOf(__shadow__::__reco__EvtPlane, label_), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class EvtPlane -------------------
void __reco__EvtPlane_db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("angle"), method_19406, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("sumSin"), method_19407, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_102), Reflex::Literal("sumCos"), method_19408, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2287), Reflex::Literal("label"), method_19409, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<reco::EvtPlane> -------------------------------
static void constructor_16725( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::EvtPlane>();
  else ::new(mem) ::edm::Wrapper<reco::EvtPlane>();
}

static void constructor_16726( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::EvtPlane>(*(::std::auto_ptr<reco::EvtPlane>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::EvtPlane>(*(::std::auto_ptr<reco::EvtPlane>*)arg[0]);
}

static void destructor_16727(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<reco::EvtPlane>*)o)->::edm::Wrapper<reco::EvtPlane>::~Wrapper)();
}
static  void method_16728( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::EvtPlane>*)o)->product)());
  else   (((const ::edm::Wrapper<reco::EvtPlane>*)o)->product)();
}

static  void operator_16729( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<reco::EvtPlane>*)o)->operator->)());
  else   (((const ::edm::Wrapper<reco::EvtPlane>*)o)->operator->)();
}

static  void method_16730( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::EvtPlane>*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<reco::EvtPlane>*)o)->productTypeInfo)();
}

static  void method_16731( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<reco::EvtPlane>*)o)->typeInfo)();
  else   (((::edm::Wrapper<reco::EvtPlane>*)o)->typeInfo)();
}

static void constructor_16732( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<reco::EvtPlane>((::reco::EvtPlane*)arg[0]);
  else ::new(mem) ::edm::Wrapper<reco::EvtPlane>((::reco::EvtPlane*)arg[0]);
}

static  void method_16733( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<reco::EvtPlane>*)o)->getInterface)());
  else   (((::edm::Wrapper<reco::EvtPlane>*)o)->getInterface)();
}

static  void method_16734( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::EvtPlane>*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16735( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::EvtPlane>*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16736( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<reco::EvtPlane>*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16737( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::EvtPlane>*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<reco::EvtPlane>*)o)->dynamicTypeInfo)();
}

static  void method_16738( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<reco::EvtPlane>*)o)->isPresent)());
  else   (((const ::edm::Wrapper<reco::EvtPlane>*)o)->isPresent)();
}

static  void method_16739( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<reco::EvtPlane>*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<reco::EvtPlane>*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4155( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::EvtPlane> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::EvtPlane> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::EvtPlane> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::EvtPlane> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<reco::EvtPlane> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<reco::EvtPlane> -------------------------------
void __edm__Wrapper_reco__EvtPlane__db_datamem(Reflex::Class*);
void __edm__Wrapper_reco__EvtPlane__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__EvtPlane__datamem_bld(&__edm__Wrapper_reco__EvtPlane__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_reco__EvtPlane__funcmem_bld(&__edm__Wrapper_reco__EvtPlane__db_funcmem);
void __edm__Wrapper_reco__EvtPlane__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<reco::EvtPlane>"), typeid(::edm::Wrapper<reco::EvtPlane>), sizeof(::edm::Wrapper<reco::EvtPlane>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddTypedef(type_5968, Reflex::Literal("edm::Wrapper<reco::EvtPlane>::value_type"))
  .AddTypedef(type_5968, Reflex::Literal("edm::Wrapper<reco::EvtPlane>::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16725, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2490), Reflex::Literal("Wrapper"), constructor_16726, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16727, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_7110), Reflex::Literal("Wrapper"), constructor_16732, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4155, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_reco__EvtPlane__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_reco__EvtPlane__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<reco::EvtPlane> -------------------
void __edm__Wrapper_reco__EvtPlane__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1439, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_reco__EvtPlane_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_5968, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_reco__EvtPlane_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<reco::EvtPlane> -------------------
void __edm__Wrapper_reco__EvtPlane__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10796), Reflex::Literal("product"), method_16728, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10796), Reflex::Literal("operator->"), operator_16729, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("productTypeInfo"), method_16730, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("typeInfo"), method_16731, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25670), Reflex::Literal("getInterface"), method_16733, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_16806, type_21493, type_25599), Reflex::Literal("fillView"), method_16734, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_5966, type_297, type_7588), Reflex::Literal("setPtr"), method_16735, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_5966, type_21494, type_21493), Reflex::Literal("fillPtrVector"), method_16736, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("dynamicTypeInfo"), method_16737, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1439), Reflex::Literal("isPresent"), method_16738, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("dynamicTypeInfo_"), method_16739, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class vector<reco::Centrality,std::allocator<reco::Centrality> > -------------------------------
static void constructor_10874( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::Centrality>();
  else ::new(mem) ::std::vector<reco::Centrality>();
}

static void constructor_10875( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::Centrality>(*(const ::std::allocator<reco::Centrality>*)arg[0]);
  else ::new(mem) ::std::vector<reco::Centrality>(*(const ::std::allocator<reco::Centrality>*)arg[0]);
}

static void constructor_10876( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::Centrality>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::Centrality>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::Centrality>(*(::std::size_t*)arg[0],
      *(const ::reco::Centrality*)arg[1]);
  else ::new(mem) ::std::vector<reco::Centrality>(*(::std::size_t*)arg[0],
      *(const ::reco::Centrality*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::Centrality>(*(::std::size_t*)arg[0],
      *(const ::reco::Centrality*)arg[1],
      *(const ::std::allocator<reco::Centrality>*)arg[2]);
  else ::new(mem) ::std::vector<reco::Centrality>(*(::std::size_t*)arg[0],
      *(const ::reco::Centrality*)arg[1],
      *(const ::std::allocator<reco::Centrality>*)arg[2]);
  }
}

static void constructor_10877( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::Centrality>(*(const ::std::vector<reco::Centrality>*)arg[0]);
  else ::new(mem) ::std::vector<reco::Centrality>(*(const ::std::vector<reco::Centrality>*)arg[0]);
}

static void destructor_10878(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::Centrality>*)o)->::std::vector<reco::Centrality>::~vector)();
}
static  void operator_10879( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::Centrality>*)o)->operator=)(*(const ::std::vector<reco::Centrality>*)arg[0]);
  else   (((::std::vector<reco::Centrality>*)o)->operator=)(*(const ::std::vector<reco::Centrality>*)arg[0]);
}

static  void method_10880( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::Centrality>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::Centrality*)arg[1]);
}

static  void method_10881( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> >)((((::std::vector<reco::Centrality>*)o)->begin)());
  else   (((::std::vector<reco::Centrality>*)o)->begin)();
}

static  void method_10882( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::Centrality*,std::vector<reco::Centrality> >)((((const ::std::vector<reco::Centrality>*)o)->begin)());
  else   (((const ::std::vector<reco::Centrality>*)o)->begin)();
}

static  void method_10883( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> >)((((::std::vector<reco::Centrality>*)o)->end)());
  else   (((::std::vector<reco::Centrality>*)o)->end)();
}

static  void method_10884( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::Centrality*,std::vector<reco::Centrality> >)((((const ::std::vector<reco::Centrality>*)o)->end)());
  else   (((const ::std::vector<reco::Centrality>*)o)->end)();
}

static  void method_10889( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::Centrality>*)o)->size)());
  else   (((const ::std::vector<reco::Centrality>*)o)->size)();
}

static  void method_10890( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::Centrality>*)o)->max_size)());
  else   (((const ::std::vector<reco::Centrality>*)o)->max_size)();
}

static  void method_10891( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::Centrality>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::Centrality>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::Centrality*)arg[1]);
  }
}

static  void method_10892( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::Centrality>*)o)->capacity)());
  else   (((const ::std::vector<reco::Centrality>*)o)->capacity)();
}

static  void method_10893( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::Centrality>*)o)->empty)());
  else   (((const ::std::vector<reco::Centrality>*)o)->empty)();
}

static  void method_10894( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::Centrality>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10895( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::Centrality>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::Centrality>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10896( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::Centrality>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::Centrality>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10898( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::Centrality>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::Centrality>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10899( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::Centrality>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::Centrality>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10900( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::Centrality>*)o)->front)();
  else   (((::std::vector<reco::Centrality>*)o)->front)();
}

static  void method_10901( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::Centrality>*)o)->front)();
  else   (((const ::std::vector<reco::Centrality>*)o)->front)();
}

static  void method_10902( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::Centrality>*)o)->back)();
  else   (((::std::vector<reco::Centrality>*)o)->back)();
}

static  void method_10903( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::Centrality>*)o)->back)();
  else   (((const ::std::vector<reco::Centrality>*)o)->back)();
}

static  void method_10904( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::Centrality>*)o)->data)());
  else   (((::std::vector<reco::Centrality>*)o)->data)();
}

static  void method_10905( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::Centrality>*)o)->data)());
  else   (((const ::std::vector<reco::Centrality>*)o)->data)();
}

static  void method_10906( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::Centrality>*)o)->push_back)(*(const ::reco::Centrality*)arg[0]);
}

static  void method_10907( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::Centrality>*)o)->pop_back)();
}

static  void method_10908( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> >)((((::std::vector<reco::Centrality>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> >*)arg[0],
    *(const ::reco::Centrality*)arg[1]));
  else   (((::std::vector<reco::Centrality>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> >*)arg[0],
    *(const ::reco::Centrality*)arg[1]);
}

static  void method_10909( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::Centrality>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::Centrality*)arg[2]);
}

static  void method_10910( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> >)((((::std::vector<reco::Centrality>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> >*)arg[0]));
  else   (((::std::vector<reco::Centrality>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> >*)arg[0]);
}

static  void method_10911( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> >)((((::std::vector<reco::Centrality>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> >*)arg[1]));
  else   (((::std::vector<reco::Centrality>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::Centrality*,std::vector<reco::Centrality> >*)arg[1]);
}

static  void method_10912( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::Centrality>*)o)->swap)(*(::std::vector<reco::Centrality>*)arg[0]);
}

static  void method_10913( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::Centrality>*)o)->clear)();
}

static void method_newdel_2726( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::Centrality> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::Centrality> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::Centrality> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::Centrality> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::Centrality> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x9( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::Centrality,std::allocator<reco::Centrality> >")), ::Reflex::BaseOffset< ::std::vector<reco::Centrality>,::std::_Vector_base<reco::Centrality,std::allocator<reco::Centrality> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x10( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::Centrality> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::Centrality> >::Generate();
}

//------Dictionary for class vector<reco::Centrality,std::allocator<reco::Centrality> > -------------------------------
void __std__vector_reco__Centrality__db_datamem(Reflex::Class*);
void __std__vector_reco__Centrality__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__Centrality__datamem_bld(&__std__vector_reco__Centrality__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__Centrality__funcmem_bld(&__std__vector_reco__Centrality__db_funcmem);
void __std__vector_reco__Centrality__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::Centrality>"), typeid(::std::vector<reco::Centrality>), sizeof(::std::vector<reco::Centrality>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2275, ::Reflex::BaseOffset< ::std::vector<reco::Centrality>, ::std::_Vector_base<reco::Centrality,std::allocator<reco::Centrality> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_5969, Reflex::Literal("std::vector<reco::Centrality>::_Alloc_value_type"))
  .AddTypedef(type_2275, Reflex::Literal("std::vector<reco::Centrality>::_Base"))
  .AddTypedef(type_2974, Reflex::Literal("std::vector<reco::Centrality>::_Tp_alloc_type"))
  .AddTypedef(type_4871, Reflex::Literal("std::vector<reco::Centrality>::_Alloc_traits"))
  .AddTypedef(type_5969, Reflex::Literal("std::vector<reco::Centrality>::value_type"))
  .AddTypedef(type_7129, Reflex::Literal("std::vector<reco::Centrality>::pointer"))
  .AddTypedef(type_10861, Reflex::Literal("std::vector<reco::Centrality>::const_pointer"))
  .AddTypedef(type_10863, Reflex::Literal("std::vector<reco::Centrality>::reference"))
  .AddTypedef(type_10865, Reflex::Literal("std::vector<reco::Centrality>::const_reference"))
  .AddTypedef(type_4800, Reflex::Literal("std::vector<reco::Centrality>::iterator"))
  .AddTypedef(type_4801, Reflex::Literal("std::vector<reco::Centrality>::const_iterator"))
  .AddTypedef(type_3096, Reflex::Literal("std::vector<reco::Centrality>::const_reverse_iterator"))
  .AddTypedef(type_3097, Reflex::Literal("std::vector<reco::Centrality>::reverse_iterator"))
  .AddTypedef(type_2924, Reflex::Literal("std::vector<reco::Centrality>::size_type"))
  .AddTypedef(type_2823, Reflex::Literal("std::vector<reco::Centrality>::difference_type"))
  .AddTypedef(type_2974, Reflex::Literal("std::vector<reco::Centrality>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10874, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20965), Reflex::Literal("vector"), constructor_10875, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2924, type_10865, type_20965), Reflex::Literal("vector"), constructor_10876, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21539), Reflex::Literal("vector"), constructor_10877, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10878, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2726, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x9, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x10, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__Centrality__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::Centrality,std::allocator<reco::Centrality> > -------------------
void __std__vector_reco__Centrality__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::Centrality,std::allocator<reco::Centrality> > -------------------
void __std__vector_reco__Centrality__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21540, type_21539), Reflex::Literal("operator="), operator_10879, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_2924, type_10865), Reflex::Literal("assign"), method_10880, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4800), Reflex::Literal("begin"), method_10881, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4801), Reflex::Literal("begin"), method_10882, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4800), Reflex::Literal("end"), method_10883, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4801), Reflex::Literal("end"), method_10884, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2924), Reflex::Literal("size"), method_10889, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2924), Reflex::Literal("max_size"), method_10890, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_2924, type_5969), Reflex::Literal("resize"), method_10891, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2924), Reflex::Literal("capacity"), method_10892, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1439), Reflex::Literal("empty"), method_10893, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_2924), Reflex::Literal("reserve"), method_10894, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10863, type_2924), Reflex::Literal("operator[]"), operator_10895, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10865, type_2924), Reflex::Literal("operator[]"), operator_10896, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10863, type_2924), Reflex::Literal("at"), method_10898, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10865, type_2924), Reflex::Literal("at"), method_10899, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10863), Reflex::Literal("front"), method_10900, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10865), Reflex::Literal("front"), method_10901, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10863), Reflex::Literal("back"), method_10902, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10865), Reflex::Literal("back"), method_10903, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7129), Reflex::Literal("data"), method_10904, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10861), Reflex::Literal("data"), method_10905, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_10865), Reflex::Literal("push_back"), method_10906, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236), Reflex::Literal("pop_back"), method_10907, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4800, type_4800, type_10865), Reflex::Literal("insert"), method_10908, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_4800, type_2924, type_10865), Reflex::Literal("insert"), method_10909, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4800, type_4800), Reflex::Literal("erase"), method_10910, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4800, type_4800, type_4800), Reflex::Literal("erase"), method_10911, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_21540), Reflex::Literal("swap"), method_10912, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236), Reflex::Literal("clear"), method_10913, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class vector<reco::EvtPlane,std::allocator<reco::EvtPlane> > -------------------------------
static void constructor_10809( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::EvtPlane>();
  else ::new(mem) ::std::vector<reco::EvtPlane>();
}

static void constructor_10810( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::EvtPlane>(*(const ::std::allocator<reco::EvtPlane>*)arg[0]);
  else ::new(mem) ::std::vector<reco::EvtPlane>(*(const ::std::allocator<reco::EvtPlane>*)arg[0]);
}

static void constructor_10811( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if ( arg.size() == 1 ) {
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::EvtPlane>(*(::std::size_t*)arg[0]);
  else ::new(mem) ::std::vector<reco::EvtPlane>(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::EvtPlane>(*(::std::size_t*)arg[0],
      *(const ::reco::EvtPlane*)arg[1]);
  else ::new(mem) ::std::vector<reco::EvtPlane>(*(::std::size_t*)arg[0],
      *(const ::reco::EvtPlane*)arg[1]);
  }
  else if ( arg.size() == 3 ) { 
    if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::EvtPlane>(*(::std::size_t*)arg[0],
      *(const ::reco::EvtPlane*)arg[1],
      *(const ::std::allocator<reco::EvtPlane>*)arg[2]);
  else ::new(mem) ::std::vector<reco::EvtPlane>(*(::std::size_t*)arg[0],
      *(const ::reco::EvtPlane*)arg[1],
      *(const ::std::allocator<reco::EvtPlane>*)arg[2]);
  }
}

static void constructor_10812( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::std::vector<reco::EvtPlane>(*(const ::std::vector<reco::EvtPlane>*)arg[0]);
  else ::new(mem) ::std::vector<reco::EvtPlane>(*(const ::std::vector<reco::EvtPlane>*)arg[0]);
}

static void destructor_10813(void*, void * o, const std::vector<void*>&, void *) {
(((::std::vector<reco::EvtPlane>*)o)->::std::vector<reco::EvtPlane>::~vector)();
}
static  void operator_10814( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::EvtPlane>*)o)->operator=)(*(const ::std::vector<reco::EvtPlane>*)arg[0]);
  else   (((::std::vector<reco::EvtPlane>*)o)->operator=)(*(const ::std::vector<reco::EvtPlane>*)arg[0]);
}

static  void method_10815( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::EvtPlane>*)o)->assign)(*(::std::size_t*)arg[0],
    *(const ::reco::EvtPlane*)arg[1]);
}

static  void method_10816( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> >)((((::std::vector<reco::EvtPlane>*)o)->begin)());
  else   (((::std::vector<reco::EvtPlane>*)o)->begin)();
}

static  void method_10817( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::EvtPlane*,std::vector<reco::EvtPlane> >)((((const ::std::vector<reco::EvtPlane>*)o)->begin)());
  else   (((const ::std::vector<reco::EvtPlane>*)o)->begin)();
}

static  void method_10818( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> >)((((::std::vector<reco::EvtPlane>*)o)->end)());
  else   (((::std::vector<reco::EvtPlane>*)o)->end)();
}

static  void method_10819( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<const reco::EvtPlane*,std::vector<reco::EvtPlane> >)((((const ::std::vector<reco::EvtPlane>*)o)->end)());
  else   (((const ::std::vector<reco::EvtPlane>*)o)->end)();
}

static  void method_10824( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::EvtPlane>*)o)->size)());
  else   (((const ::std::vector<reco::EvtPlane>*)o)->size)();
}

static  void method_10825( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::EvtPlane>*)o)->max_size)());
  else   (((const ::std::vector<reco::EvtPlane>*)o)->max_size)();
}

static  void method_10826( void*, void* o, const std::vector<void*>& arg, void*)
{
  if ( arg.size() == 1 ) {
    (((::std::vector<reco::EvtPlane>*)o)->resize)(*(::std::size_t*)arg[0]);
  }
  else if ( arg.size() == 2 ) { 
    (((::std::vector<reco::EvtPlane>*)o)->resize)(*(::std::size_t*)arg[0],
      *(::reco::EvtPlane*)arg[1]);
  }
}

static  void method_10827( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (std::size_t)((((const ::std::vector<reco::EvtPlane>*)o)->capacity)());
  else   (((const ::std::vector<reco::EvtPlane>*)o)->capacity)();
}

static  void method_10828( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::std::vector<reco::EvtPlane>*)o)->empty)());
  else   (((const ::std::vector<reco::EvtPlane>*)o)->empty)();
}

static  void method_10829( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::EvtPlane>*)o)->reserve)(*(::std::size_t*)arg[0]);
}

static  void operator_10830( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::EvtPlane>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::EvtPlane>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void operator_10831( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::EvtPlane>*)o)->operator[])(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::EvtPlane>*)o)->operator[])(*(::std::size_t*)arg[0]);
}

static  void method_10833( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::EvtPlane>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((::std::vector<reco::EvtPlane>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10834( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::EvtPlane>*)o)->at)(*(::std::size_t*)arg[0]);
  else   (((const ::std::vector<reco::EvtPlane>*)o)->at)(*(::std::size_t*)arg[0]);
}

static  void method_10835( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::EvtPlane>*)o)->front)();
  else   (((::std::vector<reco::EvtPlane>*)o)->front)();
}

static  void method_10836( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::EvtPlane>*)o)->front)();
  else   (((const ::std::vector<reco::EvtPlane>*)o)->front)();
}

static  void method_10837( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::std::vector<reco::EvtPlane>*)o)->back)();
  else   (((::std::vector<reco::EvtPlane>*)o)->back)();
}

static  void method_10838( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::std::vector<reco::EvtPlane>*)o)->back)();
  else   (((const ::std::vector<reco::EvtPlane>*)o)->back)();
}

static  void method_10839( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::std::vector<reco::EvtPlane>*)o)->data)());
  else   (((::std::vector<reco::EvtPlane>*)o)->data)();
}

static  void method_10840( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::std::vector<reco::EvtPlane>*)o)->data)());
  else   (((const ::std::vector<reco::EvtPlane>*)o)->data)();
}

static  void method_10841( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::EvtPlane>*)o)->push_back)(*(const ::reco::EvtPlane*)arg[0]);
}

static  void method_10842( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::EvtPlane>*)o)->pop_back)();
}

static  void method_10843( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> >)((((::std::vector<reco::EvtPlane>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> >*)arg[0],
    *(const ::reco::EvtPlane*)arg[1]));
  else   (((::std::vector<reco::EvtPlane>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> >*)arg[0],
    *(const ::reco::EvtPlane*)arg[1]);
}

static  void method_10844( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::EvtPlane>*)o)->insert)(*(::__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> >*)arg[0],
    *(::std::size_t*)arg[1],
    *(const ::reco::EvtPlane*)arg[2]);
}

static  void method_10845( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> >)((((::std::vector<reco::EvtPlane>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> >*)arg[0]));
  else   (((::std::vector<reco::EvtPlane>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> >*)arg[0]);
}

static  void method_10846( void* retaddr, void* o, const std::vector<void*>& arg, void*)
{
  if (retaddr) new (retaddr) (__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> >)((((::std::vector<reco::EvtPlane>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> >*)arg[1]));
  else   (((::std::vector<reco::EvtPlane>*)o)->erase)(*(::__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> >*)arg[0],
    *(::__gnu_cxx::__normal_iterator<reco::EvtPlane*,std::vector<reco::EvtPlane> >*)arg[1]);
}

static  void method_10847( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((::std::vector<reco::EvtPlane>*)o)->swap)(*(::std::vector<reco::EvtPlane>*)arg[0]);
}

static  void method_10848( void*, void* o, const std::vector<void*>&, void*)
{
  (((::std::vector<reco::EvtPlane>*)o)->clear)();
}

static void method_newdel_2725( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::std::vector<reco::EvtPlane> >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::std::vector<reco::EvtPlane> >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::std::vector<reco::EvtPlane> >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::std::vector<reco::EvtPlane> >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::std::vector<reco::EvtPlane> >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

static void method_x12( void* retaddr, void*, const std::vector<void*>&, void*)
{
  typedef std::vector<std::pair< ::Reflex::Base, int> > Bases_t;
  static Bases_t s_bases;
  if ( !s_bases.size() ) {
    s_bases.push_back(std::make_pair(::Reflex::Base( ::Reflex::TypeBuilder(Reflex::Literal("std::_Vector_base<reco::EvtPlane,std::allocator<reco::EvtPlane> >")), ::Reflex::BaseOffset< ::std::vector<reco::EvtPlane>,::std::_Vector_base<reco::EvtPlane,std::allocator<reco::EvtPlane> > >::Get(),::Reflex::PROTECTED), 0));
  }
  if (retaddr) *(Bases_t**)retaddr = &s_bases;
}

static void method_x13( void* retaddr, void*, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**) retaddr = ::Reflex::Proxy< ::std::vector<reco::EvtPlane> >::Generate();
  else ::Reflex::Proxy< ::std::vector<reco::EvtPlane> >::Generate();
}

//------Dictionary for class vector<reco::EvtPlane,std::allocator<reco::EvtPlane> > -------------------------------
void __std__vector_reco__EvtPlane__db_datamem(Reflex::Class*);
void __std__vector_reco__EvtPlane__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __std__vector_reco__EvtPlane__datamem_bld(&__std__vector_reco__EvtPlane__db_datamem);
Reflex::GenreflexMemberBuilder __std__vector_reco__EvtPlane__funcmem_bld(&__std__vector_reco__EvtPlane__db_funcmem);
void __std__vector_reco__EvtPlane__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("std::vector<reco::EvtPlane>"), typeid(::std::vector<reco::EvtPlane>), sizeof(::std::vector<reco::EvtPlane>), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddBase(type_2274, ::Reflex::BaseOffset< ::std::vector<reco::EvtPlane>, ::std::_Vector_base<reco::EvtPlane,std::allocator<reco::EvtPlane> > >::Get(), ::Reflex::PROTECTED)
  .AddTypedef(type_5968, Reflex::Literal("std::vector<reco::EvtPlane>::_Alloc_value_type"))
  .AddTypedef(type_2274, Reflex::Literal("std::vector<reco::EvtPlane>::_Base"))
  .AddTypedef(type_2973, Reflex::Literal("std::vector<reco::EvtPlane>::_Tp_alloc_type"))
  .AddTypedef(type_4870, Reflex::Literal("std::vector<reco::EvtPlane>::_Alloc_traits"))
  .AddTypedef(type_5968, Reflex::Literal("std::vector<reco::EvtPlane>::value_type"))
  .AddTypedef(type_7110, Reflex::Literal("std::vector<reco::EvtPlane>::pointer"))
  .AddTypedef(type_10796, Reflex::Literal("std::vector<reco::EvtPlane>::const_pointer"))
  .AddTypedef(type_10798, Reflex::Literal("std::vector<reco::EvtPlane>::reference"))
  .AddTypedef(type_10800, Reflex::Literal("std::vector<reco::EvtPlane>::const_reference"))
  .AddTypedef(type_4798, Reflex::Literal("std::vector<reco::EvtPlane>::iterator"))
  .AddTypedef(type_4799, Reflex::Literal("std::vector<reco::EvtPlane>::const_iterator"))
  .AddTypedef(type_3094, Reflex::Literal("std::vector<reco::EvtPlane>::const_reverse_iterator"))
  .AddTypedef(type_3095, Reflex::Literal("std::vector<reco::EvtPlane>::reverse_iterator"))
  .AddTypedef(type_2924, Reflex::Literal("std::vector<reco::EvtPlane>::size_type"))
  .AddTypedef(type_2823, Reflex::Literal("std::vector<reco::EvtPlane>::difference_type"))
  .AddTypedef(type_2973, Reflex::Literal("std::vector<reco::EvtPlane>::allocator_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("vector"), constructor_10809, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_20952), Reflex::Literal("vector"), constructor_10810, 0, "__a", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2924, type_10800, type_20952), Reflex::Literal("vector"), constructor_10811, 0, "__n;__value=_Tp();__a=_Alloc()", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_21536), Reflex::Literal("vector"), constructor_10812, 0, "__x", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~vector"), destructor_10813, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_2725, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getBasesTable"), method_x12, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddFunctionMember<void*(void)>(Reflex::Literal("createCollFuncTable"), method_x13, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandFunctionMemberBuilder(&__std__vector_reco__EvtPlane__funcmem_bld);
}

//------Delayed data member builder for class vector<reco::EvtPlane,std::allocator<reco::EvtPlane> > -------------------
void __std__vector_reco__EvtPlane__db_datamem(Reflex::Class*) {

}
//------Delayed function member builder for class vector<reco::EvtPlane,std::allocator<reco::EvtPlane> > -------------------
void __std__vector_reco__EvtPlane__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_21537, type_21536), Reflex::Literal("operator="), operator_10814, 0, "__x", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_2924, type_10800), Reflex::Literal("assign"), method_10815, 0, "__n;__val", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4798), Reflex::Literal("begin"), method_10816, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4799), Reflex::Literal("begin"), method_10817, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4798), Reflex::Literal("end"), method_10818, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4799), Reflex::Literal("end"), method_10819, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2924), Reflex::Literal("size"), method_10824, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2924), Reflex::Literal("max_size"), method_10825, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_2924, type_5968), Reflex::Literal("resize"), method_10826, 0, "__new_size;__x=_Tp()", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_2924), Reflex::Literal("capacity"), method_10827, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1439), Reflex::Literal("empty"), method_10828, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_2924), Reflex::Literal("reserve"), method_10829, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10798, type_2924), Reflex::Literal("operator[]"), operator_10830, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10800, type_2924), Reflex::Literal("operator[]"), operator_10831, 0, "__n", ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10798, type_2924), Reflex::Literal("at"), method_10833, 0, "__n", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10800, type_2924), Reflex::Literal("at"), method_10834, 0, "__n", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10798), Reflex::Literal("front"), method_10835, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10800), Reflex::Literal("front"), method_10836, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10798), Reflex::Literal("back"), method_10837, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10800), Reflex::Literal("back"), method_10838, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_7110), Reflex::Literal("data"), method_10839, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_10796), Reflex::Literal("data"), method_10840, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_10800), Reflex::Literal("push_back"), method_10841, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236), Reflex::Literal("pop_back"), method_10842, 0, 0, ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4798, type_4798, type_10800), Reflex::Literal("insert"), method_10843, 0, "__position;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_4798, type_2924, type_10800), Reflex::Literal("insert"), method_10844, 0, "__position;__n;__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4798, type_4798), Reflex::Literal("erase"), method_10845, 0, "__position", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_4798, type_4798, type_4798), Reflex::Literal("erase"), method_10846, 0, "__first;__last", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_21537), Reflex::Literal("swap"), method_10847, 0, "__x", ::Reflex::PUBLIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236), Reflex::Literal("clear"), method_10848, 0, 0, ::Reflex::PUBLIC);
}
//------Stub functions for class Wrapper<std::vector<reco::EvtPlane, std::allocator<reco::EvtPlane> > > -------------------------------
static void constructor_16662( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::EvtPlane> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::EvtPlane> >();
}

static void constructor_16663( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::EvtPlane> >(*(::std::auto_ptr<std::vector<reco::EvtPlane> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::EvtPlane> >(*(::std::auto_ptr<std::vector<reco::EvtPlane> >*)arg[0]);
}

static void destructor_16664(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->::edm::Wrapper<std::vector<reco::EvtPlane> >::~Wrapper)();
}
static  void method_16665( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->product)();
}

static  void operator_16666( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->operator->)();
}

static  void method_16667( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->productTypeInfo)();
}

static  void method_16668( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->typeInfo)();
}

static void constructor_16669( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::EvtPlane> >((::std::vector<reco::EvtPlane>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::EvtPlane> >((::std::vector<reco::EvtPlane>*)arg[0]);
}

static  void method_16670( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->getInterface)();
}

static  void method_16671( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16672( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16673( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16674( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->dynamicTypeInfo)();
}

static  void method_16675( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->isPresent)();
}

static  void method_16676( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::EvtPlane> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4152( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::EvtPlane> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::EvtPlane> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::EvtPlane> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::EvtPlane> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::EvtPlane> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::EvtPlane, std::allocator<reco::EvtPlane> > > -------------------------------
void __edm__Wrapper_std__vector_reco__EvtPlane_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__EvtPlane_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__EvtPlane_s__datamem_bld(&__edm__Wrapper_std__vector_reco__EvtPlane_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__EvtPlane_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__EvtPlane_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__EvtPlane_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::EvtPlane> >"), typeid(::edm::Wrapper<std::vector<reco::EvtPlane> >), sizeof(::edm::Wrapper<std::vector<reco::EvtPlane> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::EvtPlaneCollection>")
  .AddTypedef(type_2725, Reflex::Literal("edm::Wrapper<std::vector<reco::EvtPlane> >::value_type"))
  .AddTypedef(type_2725, Reflex::Literal("edm::Wrapper<std::vector<reco::EvtPlane> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16662, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2487), Reflex::Literal("Wrapper"), constructor_16663, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16664, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25658), Reflex::Literal("Wrapper"), constructor_16669, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4152, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__EvtPlane_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__EvtPlane_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::EvtPlane, std::allocator<reco::EvtPlane> > > -------------------
void __edm__Wrapper_std__vector_reco__EvtPlane_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1439, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__EvtPlane_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2725, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__EvtPlane_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::EvtPlane, std::allocator<reco::EvtPlane> > > -------------------
void __edm__Wrapper_std__vector_reco__EvtPlane_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25657), Reflex::Literal("product"), method_16665, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25657), Reflex::Literal("operator->"), operator_16666, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("productTypeInfo"), method_16667, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("typeInfo"), method_16668, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25659), Reflex::Literal("getInterface"), method_16670, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_16806, type_21493, type_25599), Reflex::Literal("fillView"), method_16671, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_5966, type_297, type_7588), Reflex::Literal("setPtr"), method_16672, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_5966, type_21494, type_21493), Reflex::Literal("fillPtrVector"), method_16673, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("dynamicTypeInfo"), method_16674, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1439), Reflex::Literal("isPresent"), method_16675, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("dynamicTypeInfo_"), method_16676, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
//------Stub functions for class Wrapper<std::vector<reco::Centrality, std::allocator<reco::Centrality> > > -------------------------------
static void constructor_16683( void* retaddr, void* mem, const std::vector<void*>&, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::Centrality> >();
  else ::new(mem) ::edm::Wrapper<std::vector<reco::Centrality> >();
}

static void constructor_16684( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::Centrality> >(*(::std::auto_ptr<std::vector<reco::Centrality> >*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::Centrality> >(*(::std::auto_ptr<std::vector<reco::Centrality> >*)arg[0]);
}

static void destructor_16685(void*, void * o, const std::vector<void*>&, void *) {
(((::edm::Wrapper<std::vector<reco::Centrality> >*)o)->::edm::Wrapper<std::vector<reco::Centrality> >::~Wrapper)();
}
static  void method_16686( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::Centrality> >*)o)->product)());
  else   (((const ::edm::Wrapper<std::vector<reco::Centrality> >*)o)->product)();
}

static  void operator_16687( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((const ::edm::Wrapper<std::vector<reco::Centrality> >*)o)->operator->)());
  else   (((const ::edm::Wrapper<std::vector<reco::Centrality> >*)o)->operator->)();
}

static  void method_16688( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::Centrality> >*)o)->productTypeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::Centrality> >*)o)->productTypeInfo)();
}

static  void method_16689( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((::edm::Wrapper<std::vector<reco::Centrality> >*)o)->typeInfo)();
  else   (((::edm::Wrapper<std::vector<reco::Centrality> >*)o)->typeInfo)();
}

static void constructor_16690( void* retaddr, void* mem, const std::vector<void*>& arg, void*) {
  if (retaddr) *(void**)retaddr = ::new(mem) ::edm::Wrapper<std::vector<reco::Centrality> >((::std::vector<reco::Centrality>*)arg[0]);
  else ::new(mem) ::edm::Wrapper<std::vector<reco::Centrality> >((::std::vector<reco::Centrality>*)arg[0]);
}

static  void method_16691( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = Reflex::FuncToVoidPtr((((::edm::Wrapper<std::vector<reco::Centrality> >*)o)->getInterface)());
  else   (((::edm::Wrapper<std::vector<reco::Centrality> >*)o)->getInterface)();
}

static  void method_16692( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::Centrality> >*)o)->fillView)(*(const ::edm::ProductID*)arg[0],
    *(::std::vector<const void*>*)arg[1],
    *(::boost::shared_ptr<edm::reftobase::RefVectorHolderBase>*)arg[2]);
}

static  void method_16693( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::Centrality> >*)o)->setPtr)(*(const ::std::type_info*)arg[0],
    *(unsigned long*)arg[1],
    *(const void**)arg[2]);
}

static  void method_16694( void*, void* o, const std::vector<void*>& arg, void*)
{
  (((const ::edm::Wrapper<std::vector<reco::Centrality> >*)o)->fillPtrVector)(*(const ::std::type_info*)arg[0],
    *(const ::std::vector<unsigned long>*)arg[1],
    *(::std::vector<const void*>*)arg[2]);
}

static  void method_16695( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::Centrality> >*)o)->dynamicTypeInfo)();
  else   (((const ::edm::Wrapper<std::vector<reco::Centrality> >*)o)->dynamicTypeInfo)();
}

static  void method_16696( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) new (retaddr) (bool)((((const ::edm::Wrapper<std::vector<reco::Centrality> >*)o)->isPresent)());
  else   (((const ::edm::Wrapper<std::vector<reco::Centrality> >*)o)->isPresent)();
}

static  void method_16697( void* retaddr, void* o, const std::vector<void*>&, void*)
{
  if (retaddr) *(void**)retaddr = (void*)&(((const ::edm::Wrapper<std::vector<reco::Centrality> >*)o)->dynamicTypeInfo_)();
  else   (((const ::edm::Wrapper<std::vector<reco::Centrality> >*)o)->dynamicTypeInfo_)();
}

static void method_newdel_4153( void* retaddr, void*, const std::vector<void*>&, void*)
{
  static ::Reflex::NewDelFunctions s_funcs;
  s_funcs.fNew         = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::Centrality> > >::new_T;
  s_funcs.fNewArray    = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::Centrality> > >::newArray_T;
  s_funcs.fDelete      = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::Centrality> > >::delete_T;
  s_funcs.fDeleteArray = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::Centrality> > >::deleteArray_T;
  s_funcs.fDestructor  = ::Reflex::NewDelFunctionsT< ::edm::Wrapper<std::vector<reco::Centrality> > >::destruct_T;
  if (retaddr) *(::Reflex::NewDelFunctions**)retaddr = &s_funcs;
}

//------Dictionary for class Wrapper<std::vector<reco::Centrality, std::allocator<reco::Centrality> > > -------------------------------
void __edm__Wrapper_std__vector_reco__Centrality_s__db_datamem(Reflex::Class*);
void __edm__Wrapper_std__vector_reco__Centrality_s__db_funcmem(Reflex::Class*);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__Centrality_s__datamem_bld(&__edm__Wrapper_std__vector_reco__Centrality_s__db_datamem);
Reflex::GenreflexMemberBuilder __edm__Wrapper_std__vector_reco__Centrality_s__funcmem_bld(&__edm__Wrapper_std__vector_reco__Centrality_s__db_funcmem);
void __edm__Wrapper_std__vector_reco__Centrality_s__dict() {
  ::Reflex::ClassBuilder(Reflex::Literal("edm::Wrapper<std::vector<reco::Centrality> >"), typeid(::edm::Wrapper<std::vector<reco::Centrality> >), sizeof(::edm::Wrapper<std::vector<reco::Centrality> >), ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL, ::Reflex::CLASS)
  .AddProperty(Reflex::Literal("o_name"), "edm::Wrapper<reco::CentralityCollection>")
  .AddTypedef(type_2726, Reflex::Literal("edm::Wrapper<std::vector<reco::Centrality> >::value_type"))
  .AddTypedef(type_2726, Reflex::Literal("edm::Wrapper<std::vector<reco::Centrality> >::wrapped_type"))
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("Wrapper"), constructor_16683, 0, 0, ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_2488), Reflex::Literal("Wrapper"), constructor_16684, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::EXPLICIT | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void), Reflex::Literal("~Wrapper"), destructor_16685, 0, 0, ::Reflex::PUBLIC | ::Reflex::DESTRUCTOR )
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_void, type_25663), Reflex::Literal("Wrapper"), constructor_16690, 0, "ptr", ::Reflex::PUBLIC | ::Reflex::CONSTRUCTOR)
  .AddFunctionMember<void*(void)>(Reflex::Literal("__getNewDelFunctions"), method_newdel_4153, 0, 0, ::Reflex::PUBLIC | ::Reflex::ARTIFICIAL)
  .AddOnDemandDataMemberBuilder(&__edm__Wrapper_std__vector_reco__Centrality_s__datamem_bld)
  .AddOnDemandFunctionMemberBuilder(&__edm__Wrapper_std__vector_reco__Centrality_s__funcmem_bld);
}

//------Delayed data member builder for class Wrapper<std::vector<reco::Centrality, std::allocator<reco::Centrality> > > -------------------
void __edm__Wrapper_std__vector_reco__Centrality_s__db_datamem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddDataMember(type_1439, Reflex::Literal("present"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__Centrality_s_, present), ::Reflex::PRIVATE)
  .AddDataMember(type_2726, Reflex::Literal("obj"), OffsetOf(__shadow__::__edm__Wrapper_std__vector_reco__Centrality_s_, obj), ::Reflex::PRIVATE);
}
//------Delayed function member builder for class Wrapper<std::vector<reco::Centrality, std::allocator<reco::Centrality> > > -------------------
void __edm__Wrapper_std__vector_reco__Centrality_s__db_funcmem(Reflex::Class* cl) {
  ::Reflex::ClassBuilder(cl)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25662), Reflex::Literal("product"), method_16686, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25662), Reflex::Literal("operator->"), operator_16687, 0, 0, ::Reflex::PUBLIC | ::Reflex::OPERATOR | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("productTypeInfo"), method_16688, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("typeInfo"), method_16689, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_25664), Reflex::Literal("getInterface"), method_16691, 0, 0, ::Reflex::PUBLIC | ::Reflex::STATIC)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_16806, type_21493, type_25599), Reflex::Literal("fillView"), method_16692, 0, "id;pointers;helpers", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_5966, type_297, type_7588), Reflex::Literal("setPtr"), method_16693, 0, "iToType;iIndex;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1236, type_5966, type_21494, type_21493), Reflex::Literal("fillPtrVector"), method_16694, 0, "iToType;iIndices;oPtr", ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("dynamicTypeInfo"), method_16695, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_1439), Reflex::Literal("isPresent"), method_16696, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST)
  .AddFunctionMember(::Reflex::FunctionTypeBuilder(type_5966), Reflex::Literal("dynamicTypeInfo_"), method_16697, 0, 0, ::Reflex::PUBLIC | ::Reflex::CONST);
}
namespace {
  struct Dictionaries {
    Dictionaries() {
      Reflex::Instance initialize_reflex;
      __pat__HeavyIon_dict(); 
      __edm__Wrapper_pat__HeavyIon__dict(); 
      __reco__Centrality_dict(); 
      __edm__Wrapper_reco__Centrality__dict(); 
      __reco__EvtPlane_dict(); 
      __edm__Wrapper_reco__EvtPlane__dict(); 
      __std__vector_reco__Centrality__dict(); 
      __std__vector_reco__EvtPlane__dict(); 
      __edm__Wrapper_std__vector_reco__EvtPlane_s__dict(); 
      __edm__Wrapper_std__vector_reco__Centrality_s__dict(); 
    }
    ~Dictionaries() {
      type_6508.Unload(); // class pat::HeavyIon 
      type_4151.Unload(); // class edm::Wrapper<pat::HeavyIon> 
      type_5969.Unload(); // class reco::Centrality 
      type_4154.Unload(); // class edm::Wrapper<reco::Centrality> 
      type_5968.Unload(); // class reco::EvtPlane 
      type_4155.Unload(); // class edm::Wrapper<reco::EvtPlane> 
      type_2726.Unload(); // class std::vector<reco::Centrality> 
      type_2725.Unload(); // class std::vector<reco::EvtPlane> 
      type_4152.Unload(); // class edm::Wrapper<std::vector<reco::EvtPlane> > 
      type_4153.Unload(); // class edm::Wrapper<std::vector<reco::Centrality> > 
    }
  };
  static Dictionaries instance;
}
} // unnamed namespace
